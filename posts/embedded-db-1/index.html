<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>Embedded databases (1): The harmony of DuckDB, K√πzu and LanceDB | The Data Quarry</title><meta content="Embedded databases (1): The harmony of DuckDB, K√πzu and LanceDB" property=og:title><meta content="Prashanth Rao" name=author><meta content=en_US property=og:locale><meta content="A look at how embedded databases enable easy navigation between relational, graph and vector paradigms" name=description><meta content="A look at how embedded databases enable easy navigation between relational, graph and vector paradigms" property=og:description><link href=https://thedataquarry.github.io/posts/embedded-db-1/ rel=canonical><meta content=https://thedataquarry.github.io/posts/embedded-db-1/ property=og:url><meta content="The Data Quarry" property=og:site_name><meta content=https://thedataquarry.github.io/img/dataquarry-banner.png property=og:image><meta content=article property=og:type><meta content=2023-08-27T00:00:00+00:00 property=article:published_time><meta " content=summary_large_image name=twitter:card><meta content=https://thedataquarry.github.io/img/dataquarry-banner.png property=twitter:image><meta content="Embedded databases (1): The harmony of DuckDB, K√πzu and LanceDB" property=twitter:title><meta content=@tech_optimist name=twitter:site><meta content="A look at how embedded databases enable easy navigation between relational, graph and vector paradigms" name=description><title>Embedded databases (1): The harmony of DuckDB, K√πzu and LanceDB</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><style>body{--primary-color:#376dd9;--primary-pale-color:#698bcf1c;--inline-code-color:#444;--text-color:#444;--text-pale-color:#545967;--bg-color:#fff;--highlight-mark-color:#5f75b045;--callout-note-color:#3e70d6;--callout-important-color:#7a46cd;--callout-warning-color:#d3822b;--callout-alert-color:#d43f3f;--callout-question-color:#3089b5;--callout-tip-color:#35a06b;--main-font:"IBMPlexSans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:"IBMPlexMono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:750px;--main-max-width:750px;--avatar-size:175px;--paragraph-font-size:16px;--paragraph-line-height:1.5em;--aside-font-size:16px;--img-border-radius:4px;--inline-code-border-radius:2px}body.dark{--primary-color:#689afd;--primary-pale-color:#93acdd1c;--inline-code-color:#d2d2d2;--text-color:#ddd;--text-pale-color:#a0a0a0;--bg-color:#202124;--highlight-mark-color:#5f75b045;--callout-note-color:#698bcf;--callout-important-color:#9374c5;--callout-warning-color:#c99054;--callout-alert-color:#d35757;--callout-question-color:#5091b2;--callout-tip-color:#3ea06f}</style><link href=/main.css rel=stylesheet><script async data-website-id=01228822-c189-4b8a-93ba-733d045bf346 src=https://analytics.eu.umami.is/script.js></script><body class=post><script>if(localStorage.getItem('theme')=='dark'){document.body.classList.add('dark');const a=document.querySelector('link#hl');if(a)a.href='/hl-dark.css'}</script><header class=blur><div id=header-wrapper><nav><a href=/>The Data Quarry</a><button aria-label="toggle expand" class=separator id=toggler>::</button><span class="wrap left fold">{</span><a href=/posts>blog</a><span class="wrap-separator fold">,</span><a class=fold href=/talks>talks</a><span class="wrap-separator fold">,</span><a class=fold href=/projects>projects</a><span class="wrap right fold">} ;</span></nav><div id=btns><a rel="noreferrer noopener" aria-label=GitHub href=https://github.com/prrao87 target=_blank> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12" fill=currentColor></path></svg> </a><a rel="noreferrer noopener" aria-label=Twitter href=https://twitter.com/tech_optimist target=_blank> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><title>Twitter</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z" fill=currentColor></path></svg> </a><a rel="noreferrer noopener" aria-label=LinkedIn href=https://www.linkedin.com/in/prrao87 target=_blank> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z" fill=currentColor></path></svg> </a><a aria-label="Buy me a coffee" rel="noreferrer noopener" href=https://www.buymeacoffee.com/prrao87 target=_blank> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><title>Buy Me A Coffee</title><path d="M20.216 6.415l-.132-.666c-.119-.598-.388-1.163-1.001-1.379-.197-.069-.42-.098-.57-.241-.152-.143-.196-.366-.231-.572-.065-.378-.125-.756-.192-1.133-.057-.325-.102-.69-.25-.987-.195-.4-.597-.634-.996-.788a5.723 5.723 0 00-.626-.194c-1-.263-2.05-.36-3.077-.416a25.834 25.834 0 00-3.7.062c-.915.083-1.88.184-2.75.5-.318.116-.646.256-.888.501-.297.302-.393.77-.177 1.146.154.267.415.456.692.58.36.162.737.284 1.123.366 1.075.238 2.189.331 3.287.37 1.218.05 2.437.01 3.65-.118.299-.033.598-.073.896-.119.352-.054.578-.513.474-.834-.124-.383-.457-.531-.834-.473-.466.074-.96.108-1.382.146-1.177.08-2.358.082-3.536.006a22.228 22.228 0 01-1.157-.107c-.086-.01-.18-.025-.258-.036-.243-.036-.484-.08-.724-.13-.111-.027-.111-.185 0-.212h.005c.277-.06.557-.108.838-.147h.002c.131-.009.263-.032.394-.048a25.076 25.076 0 013.426-.12c.674.019 1.347.067 2.017.144l.228.031c.267.04.533.088.798.145.392.085.895.113 1.07.542.055.137.08.288.111.431l.319 1.484a.237.237 0 01-.199.284h-.003c-.037.006-.075.01-.112.015a36.704 36.704 0 01-4.743.295 37.059 37.059 0 01-4.699-.304c-.14-.017-.293-.042-.417-.06-.326-.048-.649-.108-.973-.161-.393-.065-.768-.032-1.123.161-.29.16-.527.404-.675.701-.154.316-.199.66-.267 1-.069.34-.176.707-.135 1.056.087.753.613 1.365 1.37 1.502a39.69 39.69 0 0011.343.376.483.483 0 01.535.53l-.071.697-1.018 9.907c-.041.41-.047.832-.125 1.237-.122.637-.553 1.028-1.182 1.171-.577.131-1.165.2-1.756.205-.656.004-1.31-.025-1.966-.022-.699.004-1.556-.06-2.095-.58-.475-.458-.54-1.174-.605-1.793l-.731-7.013-.322-3.094c-.037-.351-.286-.695-.678-.678-.336.015-.718.3-.678.679l.228 2.185.949 9.112c.147 1.344 1.174 2.068 2.446 2.272.742.12 1.503.144 2.257.156.966.016 1.942.053 2.892-.122 1.408-.258 2.465-1.198 2.616-2.657.34-3.332.683-6.663 1.024-9.995l.215-2.087a.484.484 0 01.39-.426c.402-.078.787-.212 1.074-.518.455-.488.546-1.124.385-1.766zm-1.478.772c-.145.137-.363.201-.578.233-2.416.359-4.866.54-7.308.46-1.748-.06-3.477-.254-5.207-.498-.17-.024-.353-.055-.47-.18-.22-.236-.111-.71-.054-.995.052-.26.152-.609.463-.646.484-.057 1.046.148 1.526.22.577.088 1.156.159 1.737.212 2.48.226 5.002.19 7.472-.14.45-.06.899-.13 1.345-.21.399-.072.84-.206 1.08.206.166.281.188.657.162.974a.544.544 0 01-.169.364zm-6.159 3.9c-.862.37-1.84.788-3.109.788a5.884 5.884 0 01-1.569-.217l.877 9.004c.065.78.717 1.38 1.5 1.38 0 0 1.243.065 1.658.065.447 0 1.786-.065 1.786-.065.783 0 1.434-.6 1.499-1.38l.94-9.95a3.996 3.996 0 00-1.322-.238c-.826 0-1.491.284-2.26.613z" fill=currentColor></path></svg> </a><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><div id=blank></div><aside class=blur><nav><ul><li><a class=h2 href=#embedded-dbs-are-here-to-stay>Embedded DBs are here to stay</a><li><a class=h2 href=#some-background>Some background</a> <ul><li><a class=h3 href=#what-is-an-embedded-database>What is an embedded database?</a><li><a class=h3 href=#a-breakdown-of-the-landscape>A breakdown of the landscape</a></ul><li><a class=h2 href=#duckdb>DuckDB</a> <ul><li><a class=h3 href=#an-interesting-take-on-the-big-data-narrative>An interesting take on the ‚Äúbig data‚Äù narrative</a><li><a class=h3 href=#key-features-of-duckdb>Key features of DuckDB</a></ul><li><a class=h2 href=#kuzu>K√πzu</a> <ul><li><a class=h3 href=#key-features-of-kuzu>Key features of K√πzu</a><li><a class=h3 href=#goals-of-kuzu>Goals of K√πzu</a></ul><li><a class=h2 href=#lancedb>LanceDB</a> <ul><li><a class=h3 href=#key-features-of-lancedb>Key features of LanceDB</a></ul><li><a class=h2 href=#will-embedded-databases-be-commercially-successful>Will embedded databases be commercially successful?</a> <ul><li><a class=h3 href=#duckdb-motherduck>DuckDB + MotherDuck</a><li><a class=h3 href=#kuzu-1>K√πzu</a><li><a class=h3 href=#lancedb-lancedb-cloud>LanceDB + LanceDB Cloud</a></ul><li><a class=h2 href=#conclusions>Conclusions</a></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>Embedded databases (1): The harmony of DuckDB, K√πzu and LanceDB</h1><div id=post-info><div id=date><span id=publish>2023-08-27</span></div><div id=tags><a href=https://thedataquarry.github.io/tags/embedded-db><span>#</span>embedded-db</a><a href=https://thedataquarry.github.io/tags/vector-db><span>#</span>vector-db</a><a href=https://thedataquarry.github.io/tags/graph-db><span>#</span>graph-db</a></div></div><h2 id=embedded-dbs-are-here-to-stay>Embedded DBs are here to stay<a aria-label="Anchor link for: embedded-dbs-are-here-to-stay" class=zola-anchor href=#embedded-dbs-are-here-to-stay>#</a></h2><p>In the world of database systems, the client/server architecture has been by far the most widespread. Databases whose names you‚Äôre likely very familiar with, like PostgreSQL, MySQL, MongoDB and many others, fall in this camp, whose foundations were laid in the early days of the web. Back then, the client/server architecture was a natural fit because it allowed for a separation of concerns between the client (the browser) and the server (the machine hosting the database).<p>Most databases that exist today are built using the client/server architecture, where the client is responsible for rendering the user/developer interface, and the server is responsible for storing and processing the data. It‚Äôs not a stretch to say that the world has progressed a <em>long</em> way since the early days of the web. As computing power has grown exponentially, modern embedded databases are able to do a lot more, <em>with a lot less</em>.<p>Although the idea of embedded databases is not new ‚Äì SQLite has been around since 2000! ‚Äì there have been numerous research breakthroughs in the last decade, making it possible for vendors to build fast, lightweight, and easy to use alternatives to established solutions like Postgres or MySQL, especially for the massive analytical and ML workloads we‚Äôre seeing today.<p>However, a lot of these enterprise solutions are designed for ‚Äúbig‚Äù data (whatever that means for your organization). But there‚Äôs a whole ocean of use cases <em>in between</em> single-CPU, in-memory analytics and large-scale, distributed analytics. It‚Äôs in this middle ground where embedded databases shine ‚ú®, because they‚Äôre designed to be lightweight, easy to use, and are extremely performant for analytics, from small-scale (a few million) to large-scale (billion-size) datasets.<p>The aim of this series is to first gain a birds-eye view of the embedded database landscape, and how their interplay with Apache Arrow ecosystem is allowing for greater flexibility in data modelling than was possible before. From an OLAP perspective, three particular vendors are really exciting: <strong>DuckDB</strong> in the relational world, <strong>K√πzu</strong> for graphs, and <strong>LanceDB</strong> for vectors.<h2 id=some-background>Some background<a aria-label="Anchor link for: some-background" class=zola-anchor href=#some-background>#</a></h2><p>Real-world data processing workloads can be broadly broken into two: <strong>OLTP</strong> (online transactional processing and) <strong>OLAP</strong> (online analytical processing). OLTP workloads involve a lot of small, fast transactions, like updating a user‚Äôs profile, or adding a new item to a shopping cart. OLAP workloads, on the other hand, involve a lot of complex, long-running queries, like aggregating over a large dataset, or joining several large tables.<p>Over the years, the client/server architecture has been a great fit for OLTP workloads, but has been less than ideal for OLAP workloads, mainly because their underlying storage is row-oriented. This has led to a host of OLAP data warehouses being built specifically to process heavy analytical workloads, such as Snowflake, Clickhouse and BigQuery, which are designed to use columnar storage.<p>I‚Äôm focusing specifically on the 3 solutions shown below, because they‚Äôre all open-source, and importantly, <strong>they embrace unorthodoxy</strong> at their core ‚Äì they do away with existing designs, and instead innovate by starting from a clean slate.<figure><img alt="The unifying interface for modern data: Arrow" loading=lazy src=embedded-db-breakdown.png><figcaption>The unifying interface for modern data: Arrow</figcaption></figure><p>The bottom part of the image is particularly interesting: <a rel="nofollow noreferrer" href=https://arrow.apache.org/>Arrow</a>, a language-agnostic development ecosystem for in-memory data, is the common denominator between all three of these databases, allowing data from one paradigm to relatively easily be transformed into another (despite the databases themselves implementing different data models). The Arrow format was designed from the ground up to be a columnar, fast and in-memory format for flat and hierarchical data, to be efficient for analytical operations on modern CPUs and GPUs.<h3 id=what-is-an-embedded-database>What is an embedded database?<a aria-label="Anchor link for: what-is-an-embedded-database" class=zola-anchor href=#what-is-an-embedded-database>#</a></h3><p>An embedded database is an <strong>in-process</strong> database management system that‚Äôs tightly integrated with the application layer. The term ‚Äúin-process‚Äù is important because the database compute runs within the same underlying process as the application (which could be written in any language, like Python, R, JavaScript, C++). In the case of RocksDB, an open-source embedded key-value store written in C++, the application it runs inside<sup class=footnote-reference><a href=#6>1</a></sup> could <em>itself be another database</em>!<p>A key characteristic of embedded databases is how close the storage layer is to the application layer. Additionally, data that‚Äôs larger than memory can be stored and queried on-disk, allowing them to scale to pretty huge amounts of data (TB) with relatively low query latencies and response times.<blockquote class="callout note"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" fill=currentColor></path></svg></div><div class=content><p>In the database community, embedded databases are sometimes referred to as <em>serverless</em> databases, but they do not mean the same thing. In general, ‚Äúembedded‚Äù refers to ‚Äúin-process‚Äù, and ‚Äúserverless‚Äù refers to separation of storage and compute, so these terms are used in different contexts, especially to those coming from microservices backgrounds.</div></blockquote><h3 id=a-breakdown-of-the-landscape>A breakdown of the landscape<a aria-label="Anchor link for: a-breakdown-of-the-landscape" class=zola-anchor href=#a-breakdown-of-the-landscape>#</a></h3><p>The three databases we will focus on are but part of a larger landscape of embedded DBs, many of which are out of the scope of this series. However, it makes sense to first gain a birds-eye view of the breakdown of the landscape.<figure><img alt="Embedded databases organized by data model paradigm" loading=lazy src=embedded-db-landscape.png><figcaption>Embedded databases organized by data model paradigm</figcaption></figure><p>Key-value embedded stores are quite popular, due to their speed and lightweight nature, allowing them to power a host of other applications/databases downstream. However, the key-value data model is quite simplistic, allowing for limited expressivity in data modelling. The other three data model paradigms ‚Äì relational, graph and vector ‚Äì are much more powerful and expressive, and are thus the focus of this series.<hr><h2 id=duckdb>DuckDB<a aria-label="Anchor link for: duckdb" class=zola-anchor href=#duckdb>#</a></h2><p><a rel="nofollow noreferrer" href=https://duckdb.org/>DuckDB</a> is a high-performance embedded, ACID-compliant relational database system (RDBMS) that can be queried via a rich SQL dialect that‚Äôs very similar to Postgres. It‚Äôs written in C++, and is designed to be fast and easy to use. It‚Äôs designed to support large-scale OLAP query workloads, which are typically characterized by complex, relatively long-running queries that process significant portions of the stored data ‚Äì for example, aggregations over entire tables, or joins between several large tables.<h3 id=an-interesting-take-on-the-big-data-narrative>An interesting take on the ‚Äúbig data‚Äù narrative<a aria-label="Anchor link for: an-interesting-take-on-the-big-data-narrative" class=zola-anchor href=#an-interesting-take-on-the-big-data-narrative>#</a></h3><p>In early 2023, the makers of DuckDB posted a blog with a click-baity title, ‚Äú<em>Big data is dead</em>‚Äù <sup class=footnote-reference><a href=#1>2</a></sup>. It was very smartly (and aptly) countered in another article that came shortly after, ‚Äú<em>Big data is dead ‚Ä¶ Long live big data!</em>‚Äù<sup class=footnote-reference><a href=#2>3</a></sup>. Both articles are very well-written, and contain a lot of insights from folks who have spent years in the world of big data, so it‚Äôs recommended you give them both a read.<ul><li>The thesis: <a rel="nofollow noreferrer" href=https://motherduck.com/blog/big-data-is-dead/>Big data is dead</a>, by Jordan Tigani, a founding engineer at Google BigQuery, now founder and CEO of MotherDuck, DuckDB‚Äôs commercial cloud offering.<li>The antithesis: <a rel="nofollow noreferrer" href=https://ponder.io/big-data-is-dead-long-live-big-data/>Big data is dead, long live big data!</a>, by Aditya Parameswaran, Associate Professor at UC Berkeley, and co-founder of Ponder, a data science startup.</ul><p>The first blog post makes the (rather strong) claim that the age of big data is over, and that because a large fraction of organizations don‚Äôt have Google-scale data, they are thus ‚Äúoverpaying‚Äù to enterprise data warehouse vendors for features or scale that they don‚Äôt need, and a lot of their workloads could instead be run on single nodes.<p>While this is largely true, the second post rightly counters this viewpoint (while also acknowledging that DuckDB is an excellent solution), by stating that although a large fraction of organizations don‚Äôt <em>yet</em> have big data, they will have big data <em>in the future</em>, because the relationship between having data and the ability to grow it (by better leveraging insights from existing data), is nonlinear. Organizations will <em>eventually</em> reach humongous scales of data, provided they have the right tools to organically arrive at that scale, and it all starts with having multiple tools that allow them to process data at all scales, from small to large.<p>I‚Äôm very much on board with both camps! Everything has to be taken in context, for each individual use case. üòé<h3 id=key-features-of-duckdb>Key features of DuckDB<a aria-label="Anchor link for: key-features-of-duckdb" class=zola-anchor href=#key-features-of-duckdb>#</a></h3><p>All jokes aside, DuckDB is a <em>seriously</em> powerful database, with a host of unique and amazing features that are straight from the world of academic database research. As they mention in their blog<sup class=footnote-reference><a href=#3>4</a></sup>, DuckDB stands on the shoulders of giants. A few of their key features for blazing fast OLAP query performance on large datasets (involving aggregations and joins on 100M+ rows on multiple tables), are listed below.<ul><li>Like other OLAP data warehouses, DuckDB uses columnar storage, which is a great fit for analytical workloads, because it allows for fast, efficient scans over large amounts of data<li>Uses vectorized query execution, which is a technique that allows for processing large amounts of data in batches, which is a great fit for modern CPUs<li>Utilizes recent advances in query optimization, with ideas from dynamic programming to unnesting arbitrary subqueries<li>Uses concurrent execution via threads, which allows for faster execution of queries, and is a great fit for modern multi-threaded CPUs<li>Utilizes a dialect of SQL that is very similar to Postgres (unlike Clickhouse, which deviates quite far from PostgreSQL)<li><strong>Possibly the most important</strong>: DuckDB has fast become a universal data connector<sup class=footnote-reference><a href=#5>5</a></sup>, due to the sheer number of data formats it‚Äôs able to natively read data from <ul><li>A lot of ETL processes involve expensive transformations that reshape data from one form to another<li>DuckDB natively reads from formats like CSV, JSON (including nested JSON), Parquet, and has scanners to directly read from Postgres and SQLite databases<li>Thanks to the Arrow format, data can very easily move from a DuckDB table to a Pandas or Polars DataFrame, and vice-versa<li>It also offers connectors that allow users to directly read Parquet data from S3, GCS and Azure storage</ul></ul><p>Because DuckDB <strong>natively</strong> supports a lot of these formats, it‚Äôs able to perform efficient scans on-disk, without having to materialize them in-memory all the time (unlike Pandas).<figure><img alt="A productive DuckDB setup for large (100M+ size) analytical workloads" loading=lazy src=embedded-db-duckdb.png><figcaption>A productive DuckDB setup for large (100M+ size) analytical workloads</figcaption></figure><h2 id=kuzu>K√πzu<a aria-label="Anchor link for: kuzu" class=zola-anchor href=#kuzu>#</a></h2><p><a rel="nofollow noreferrer" href=https://github.com/kuzudb/kuzu>K√πzu</a> is an open-source graph database management system (GDBMS) built for query speed and scalability, and is implemented in C++. Its origins and motivations are quite similar to DuckDB on two counts, in that it utilizes an embedded architecture, and that it came from an academic environment. K√πzu comes from years of research at University of Waterloo üá®üá¶, and applies several modern techniques for storage and query processing of graph-like data. It implements the Cypher query language, based on the <a rel="nofollow noreferrer" href=https://opencypher.org/>openCypher</a> standard, allowing developers to unlock the full expressive power of graphs via a property graph data model (or <a rel="nofollow noreferrer" href=https://docs.kuzudb.com/rdf-graphs/>RDF</a>, if required).<p>A graph database, at its deepest core, despite its name, expresses a relational model. The main difference in the internals of a GDBMS and a typical relational system is that the GDBMS is optimized for storing and querying specialized data structures and join algorithms that are suited to modelling datasets with a high degree of connectivity, such social networks, recommendation engines, fraud detection, and many others.<h3 id=key-features-of-kuzu>Key features of K√πzu<a aria-label="Anchor link for: key-features-of-kuzu" class=zola-anchor href=#key-features-of-kuzu>#</a></h3><p>K√πzu, being an embedded database, incorporates cutting-edge features straight out of the world of academic database research. A few of their key features for blazing fast graph query performance are listed below, as adapted from their excellent blog post, titled ‚Äú<em>What every competent GDBMS should do‚Äù</em><sup class=footnote-reference><a href=#7>6</a></sup>.<ul><li><p><strong>Vectorized query processing</strong>: A graph database exploits the underlying relational structure of the data and stores it via an efficient columnar format in blocks, so that queries and aggregations can be processed in a vectorized fashion, fully exploiting the power of multiple threads on modern CPUs.</p><li><p><strong>Pre-defined, pointer-based joins</strong>: A graph database stores the neighbours of a <em>node</em> (a ‚Äúrecord‚Äù, or a ‚Äúrow‚Äù in SQL terminology) as pre-defined relationships. While in a relational DB, a SQL query can make no prior assumptions about which tables are being joined with each other until query time, a graph database is all about exploiting the prior knowledge of existing relationships from the data, and instead uses a join index (i.e., and adjacency list index) to store these pre-defined relationships <em>at load time</em>.</p><li><p><strong>Many-to-many growing joins</strong>: A graph database is natively designed for many-to-many joins, on data that‚Äôs ever growing. If on average, each of the nodes connects with many other nodes and there are also many relationships in the pattern being searched, we‚Äôre basically asking the system to search through an exponentially growing number of combinations! Relational (OLTP) databases, because of their row-oriented design, cannot optimize for this use case.</p><li><p><strong>Recursive joins</strong>: Graph queries excel in performance for recursive join queries when compared with SQL, mainly because of the efficiency of the graph model in ‚Äúhopping‚Äù over multiple levels of depth. Although SQL queries permit recursion, the idea of recursion was added as an afterthought in the relational data model, whereas in graphs, recursion is a first-class citizen.</p><li><p><strong>Schema querying</strong>: A special feature of graph querying that cannot be done in SQL is directly querying the <em>schema</em> of the database. A graph query in Cypher contains a subject, a predicate, and an object, and we are able to define the predicate directly on the schema, not just on the nodes/relations. This allows us to express a data modelling logic that would be a lot messier in SQL. To express the predicate (connective) logic between entities in relational tables, we would need to write a verbose query involving <code>UNION</code>s and other sub-queries, but this is just one line in Cypher (see the blog post<sup class=footnote-reference><a href=#7>6</a></sup> for examples).</p><li><p><strong>Semi-structured data handling</strong>: In many cases, we may have data that contains deeply nested JSON, involving cases where one entity can have many types (a node representing Justin Trudeau can be both of type <code>Person</code>, and of type <code>Politician</code>, depending on the logic being expressed in the data model). A labelled property graph data model allows assigning multiple labels to these entities, providing added flexibility to the developer while designing the schema for the kinds of queries expected in the application.</p></ul><h3 id=goals-of-kuzu>Goals of K√πzu<a aria-label="Anchor link for: goals-of-kuzu" class=zola-anchor href=#goals-of-kuzu>#</a></h3><p>The goals and vision of K√πzu are very well articulated in their blog post<sup class=footnote-reference><a href=#7>6</a></sup>, but the main summary is that it‚Äôs designed to be a fast, scalable and easy-to-use solution for graph data science, graph machine learning (via frameworks like PyTorch Geometric) and analytics on very large graphs (upwards of 100M nodes and 1B edges). It‚Äôs very well-integrated with the Python data science ecosystem, with client libraries in C++, Rust, Node.js, Java and of course, Python.<figure><img alt="Where K√πzu sits in the graph data science & ML Stack" loading=lazy src=embedded-db-kuzudb.png><figcaption>Where K√πzu sits in the graph data science & ML Stack</figcaption></figure><h2 id=lancedb>LanceDB<a aria-label="Anchor link for: lancedb" class=zola-anchor href=#lancedb>#</a></h2><p><a rel="nofollow noreferrer" href=https://lancedb.com>LanceDB</a> is an open-source embedded database for vector search built with persistent storage, which greatly simplifies retrieval, filtering and management of embeddings. LanceDB‚Äôs core is written in Rust ü¶Ä and is built using Lance, an open-source columnar format designed for performant ML workloads that‚Äôs 100x faster than parquet<sup class=footnote-reference><a href=#9>7</a></sup> for random access.<h3 id=key-features-of-lancedb>Key features of LanceDB<a aria-label="Anchor link for: key-features-of-lancedb" class=zola-anchor href=#key-features-of-lancedb>#</a></h3><p>Other than the fact that it uses an embedded architecture, what makes LanceDB different from the sea of other vector stores out there? I‚Äôve spent some time thinking about this, and talked numerous folks in the industry, to come up with the list below.<ul><li>Built on top of a new, efficient columnar data format, Lance, that is aimed at becoming a modern alternative to parquet that‚Äôs optimized for vector search <ul><li>Building on top of highly efficient disk-based format like Lance allows LanceDB to proceed with confidence on its own version of the DiskANN algorithm, a modern and performant ANN index ‚Äì it‚Äôs very likely that a lot of other vector DBs cannot implement DiskANN as efficiently on top of their own storage layers</ul><li>Can be queried in a number of ways, including via SQL, full-text search (via Tantivy<sup class=footnote-reference><a href=#8>8</a></sup>), and vector search (IVF-PQ, or an upcoming DiskANN index).<li>Zero-copy data access, which is a huge performance boost for disk-based indexes<li>Automatic versioning of data via Lance<sup class=footnote-reference><a href=#10>9</a></sup><li>Direct integrations with cloud storage providers like AWS S3 and Azure Blob Storage, making it possible to directly query data stored on the cloud, with no added ETL steps<li>Truly multi-modal data access, where the vector embeddings are stored alongside the actual document, not just its metadata. This allows you to persist images, audio or text documents and their embeddings in the same storage location, unlike other vector DBs, where the raw data sits separately from the embeddings/metadata.</ul><figure><img alt="Using LanceDB to power <a href='https://github.com/lancedb/vectordb-recipes/tree/main'>data science, retrieval & ML workflows</a>" loading=lazy src=embedded-db-lancedb.png><figcaption>Using LanceDB to power <a href=https://github.com/lancedb/vectordb-recipes/tree/main>data science, retrieval & ML workflows</a></figcaption></figure><hr><h2 id=will-embedded-databases-be-commercially-successful>Will embedded databases be commercially successful?<a aria-label="Anchor link for: will-embedded-databases-be-commercially-successful" class=zola-anchor href=#will-embedded-databases-be-commercially-successful>#</a></h2><p>The million-dollar question now is how commercially successful embedded databases will be in the long run. The client/server architecture has been around for a <em>very</em> long time, and has been proven to be a successful commercial model for numerous databases, which is why they are the norm in large-scale production use cases. The embedded architecture is still relatively new, at least for OLAP databases, and several vendors focusing on this section of the market are building them out as open-source technology, and are still figuring out their monetization strategies. However, the approach seems to be along the lines of the following:<ol><li>Build a sound open-source offering with the full functionality of their client/server counterparts<li>Showcase blazing fast performance üî• and ease of use<li>Gain a sizeable user community that advocates for its use<li>Offer a managed cloud service that builds on top of the open-source version, with added convenience features ‚Äì from a pricing perspective, it would be essential that the cost is on par with (or lower than) tried-and-tested client/server databases</ol><p>One can only speculate, and <strong>time</strong> will tell how successful the various monetization strategies of embedded databases will be. My personal take is that there is already ample opportunity in both small and large organizations to use embedded databases for a wide variety of use cases, and the three vendors I‚Äôve mentioned in this post, in my view, seem the best-positioned in their domains to be üí∞ commercially successful in the long run.<h3 id=duckdb-motherduck>DuckDB + MotherDuck<a aria-label="Anchor link for: duckdb-motherduck" class=zola-anchor href=#duckdb-motherduck>#</a></h3><p>In early 2023, DuckDB made a significant announcement related to its monetization strategy, with its <a rel="nofollow noreferrer" href=https://motherduck.com/company/>MotherDuck</a> commercial entity spin-off entity. MotherDuck offers the following convenience features on top of open-source offering DuckDB<sup class=footnote-reference><a href=#4>10</a></sup>, designed specifically for serverless operation on the cloud.<ul><li>Convenient persistent storage via a managed service<li>Hybrid execution mode, allowing seamlessly combining querying from in-memory, on-disk, or on-cloud, in a fully distributed fashion<li>Secrets management to handle data stored on the cloud<li>A notebook-like SQL IDE (similar to DataBricks Spark notebooks) to make data scientists and analysts more productive<li>Sharing databases with teammates</ul><h3 id=kuzu-1>K√πzu<a aria-label="Anchor link for: kuzu-1" class=zola-anchor href=#kuzu-1>#</a></h3><p>K√πzu is the furthest ahead among graph DB vendors in the quest to provide an easy-to-use and scalable embeddable graph DBMS.<ul><li><a rel="nofollow noreferrer" href=https://kuzudb.com/>K√πzu</a> is a powerful, open-source, ACID-compliant graph database <strong>ready for production</strong>, with great support for the openCypher query language <ul><li>My <a href=../embedded-db-2>experiments</a> with it show it to be blazing fast in comparison to existing solutions, and it‚Äôs able to handle large-scale graph queries using a familiar query language.</ul><li>As they mention in their blog<sup class=footnote-reference><a href=#7>6</a></sup>, K√πzu is aiming to emulate in the graph database world what DuckDB has done in the SQL world, and gain widespread adoption through a sound core that‚Äôs open-source and scalable<li>As the use cases for graph data structures & algorithms proliferate into ML/AI and LLM applications, my take is that an as-yet unannounced commercial offering from K√πzu could be hugely valuable in building analytics tools powered by graphs</ul><h3 id=lancedb-lancedb-cloud>LanceDB + LanceDB Cloud<a aria-label="Anchor link for: lancedb-lancedb-cloud" class=zola-anchor href=#lancedb-lancedb-cloud>#</a></h3><p>LanceDB has been making waves in the world of vector DBs, and it‚Äôs fast differentiated itself from its competitors by offering innovative disk-based vector indexes and search capabilities directly on cloud storage<sup class=footnote-reference><a href=#8>8</a></sup>. Due to the unique nature of <a rel="nofollow noreferrer" href=https://github.com/lancedb/lance>Lance</a>, a new, columnar data format optimized for vector compute (and on top of which LanceDB is built), the management of vector storage and versioning on the cloud is a fascinating area that LanceDB is looking poised to revolutionize. Some of the convenience features on <a rel="nofollow noreferrer" href=https://lancedb.com/>LanceDB Cloud</a> are described below.<ul><li>Managed service to store and version Lance datasets in the cloud<li>Distributed computing workloads via a managed service<li>Auto re-indexing<li>Caching layer<li>Dashboard to more conveniently manage your data</ul><h2 id=conclusions>Conclusions<a aria-label="Anchor link for: conclusions" class=zola-anchor href=#conclusions>#</a></h2><p>This post gave a rather detailed (and in my view, necessary) overview of the embedded DB landscape, specifically focusing on solutions in the relational, graph and vector paradigms. Although each of these tools is built in a different language (C++ or Rust) and caters to different data models, the interoperability features baked into underlying Arrow format effectively unify these otherwise distinct paradigms, allowing for seamless data transfer and a LOT more flexibility for complex use cases.<p>I‚Äôm firmly of the belief that these major developments will make embedded databases far more popular and accessible to data scientists and ML practitioners in the coming years. As a developer who‚Äôs interested in one and all modelling paradigms, I can only speculate on the commercial angle of these solutions. In the upcoming posts in this series, I‚Äôll go deeper into examples with code on each of these solutions.<p>Onward and upward! üöÄ<p>Other posts in this series:<ul><li><a href=../embedded-db-2>Embedded databases (2): K√πzu, an extremely fast OLAP graph database</a><li><a href=../embedded-db-3>Embedded databases (3): LanceDB and the modular data stack</a></ul><hr><div class=footnote-definition id=6><sup class=footnote-definition-label>1</sup><p>Building on top of RocksDB, <a rel="nofollow noreferrer" href=https://www.cockroachlabs.com/blog/cockroachdb-on-rocksd/>Cockroach Labs blog</a></div><div class=footnote-definition id=1><sup class=footnote-definition-label>2</sup><p><em>Big data is dead</em> by Jordan Tigani, <a rel="nofollow noreferrer" href=https://motherduck.com/blog/big-data-is-dead/>MotherDuck blog</a></div><div class=footnote-definition id=2><sup class=footnote-definition-label>3</sup><p><em>Big data is dead‚Ä¶ Long live big data!</em> by Aditya Parameswaran, <a rel="nofollow noreferrer" href=https://ponder.io/big-data-is-dead-long-live-big-data/>ponder.io</a></div><div class=footnote-definition id=3><sup class=footnote-definition-label>4</sup><p>Standing on the shoulders of giants, <a rel="nofollow noreferrer" href=https://duckdb.org/why_duckdb.html#standing-on-the-shoulders-of-giants>DuckDB docs</a></div><div class=footnote-definition id=5><sup class=footnote-definition-label>5</sup><p>Why we built Rill with DuckDB, <a rel="nofollow noreferrer" href=https://www.rilldata.com/blog/why-we-built-rill-with-duckdb>Rill blog</a></div><div class=footnote-definition id=7><sup class=footnote-definition-label>6</sup><p>What every competent graph database management system should do, <a rel="nofollow noreferrer" href=https://blog.kuzudb.com/post/what-every-gdbms-should-do-and-vision/>K√πzu blog</a></div><div class=footnote-definition id=9><sup class=footnote-definition-label>7</sup><p>Benchmarking random access in Lance, <a rel="nofollow noreferrer" href=https://blog.lancedb.com/benchmarking-random-access-in-lance/>LanceDB blog</a></div><div class=footnote-definition id=8><sup class=footnote-definition-label>8</sup><p><em>S3 backed full-text search with Tantivy</em> by Rob Meng, <a rel="nofollow noreferrer" href=https://blog.lancedb.com/s3-backed-full-text-search-with-tantivy-part-1-ac653017068b>LanceDB blog</a></div><div class=footnote-definition id=10><sup class=footnote-definition-label>9</sup><p>Building a time machine with Lance, <a rel="nofollow noreferrer" href=https://blog.lancedb.com/building-a-time-machine-with-lance-3b14ab536232>LanceDB blog</a></div><div class=footnote-definition id=4><sup class=footnote-definition-label>10</sup><p>DuckDB vs. MotherDuck, <a rel="nofollow noreferrer" href=https://kestra.io/blogs/2023-07-28-duckdb-vs-motherduck>Kestra blog</a></div></article><div class=giscus></div><script async crossorigin data-category=General data-category-id=DIC_kwDOKyWhTs4CbUSt data-emit-metadata=0 data-input-position=bottom data-lang=en data-loading=lazy data-mapping=pathname data-reactions-enabled=1 data-repo=thedataquarry/thedataquarry.github.io data-repo-id=R_kgDOKyWhTg data-strict=0 data-theme=preferred_color_scheme src=https://giscus.app/client.js></script></div><footer><div class=copyright><p>¬© 2024 Prashanth Rao</div><div class=credits>Powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div></footer></main></div><script src=/js/lightense.min.js></script><script src=/js/main.js></script>