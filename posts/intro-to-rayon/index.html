<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>Speeding up data analysis with Rayon and Rust | The Data Quarry</title><meta content="Speeding up data analysis with Rayon and Rust" property=og:title><meta content="Prashanth Rao" name=author><meta content=en_US property=og:locale><meta content="Rayon's makes data parallelism in Rust a breeze, and is blazing fast compared to Python multiprocessing. A simple walkthrough to get started." name=description><meta content="Rayon's makes data parallelism in Rust a breeze, and is blazing fast compared to Python multiprocessing. A simple walkthrough to get started." property=og:description><link href=https://thedataquarry.github.io/posts/intro-to-rayon/ rel=canonical><meta content=https://thedataquarry.github.io/posts/intro-to-rayon/ property=og:url><meta content="The Data Quarry" property=og:site_name><meta content=https://thedataquarry.github.io/img/dataquarry-banner.png property=og:image><meta content=article property=og:type><meta content=2024-02-10T00:00:00+00:00 property=article:published_time><meta " content=summary_large_image name=twitter:card><meta content=https://thedataquarry.github.io/img/dataquarry-banner.png property=twitter:image><meta content="Speeding up data analysis with Rayon and Rust" property=twitter:title><meta content=@tech_optimist name=twitter:site><meta content="Rayon's makes data parallelism in Rust a breeze, and is blazing fast compared to Python multiprocessing. A simple walkthrough to get started." name=description><title>Speeding up data analysis with Rayon and Rust</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><style>body{--primary-color:#376dd9;--primary-pale-color:#698bcf1c;--inline-code-color:#444;--text-color:#444;--text-pale-color:#545967;--bg-color:#fff;--highlight-mark-color:#5f75b045;--callout-note-color:#3e70d6;--callout-important-color:#7a46cd;--callout-warning-color:#d3822b;--callout-alert-color:#d43f3f;--callout-question-color:#3089b5;--callout-tip-color:#35a06b;--main-font:"IBMPlexSans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:"IBMPlexMono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:750px;--main-max-width:750px;--avatar-size:175px;--paragraph-font-size:16px;--paragraph-line-height:1.5em;--aside-font-size:16px;--img-border-radius:4px;--inline-code-border-radius:2px}body.dark{--primary-color:#689afd;--primary-pale-color:#93acdd1c;--inline-code-color:#d2d2d2;--text-color:#ddd;--text-pale-color:#a0a0a0;--bg-color:#202124;--highlight-mark-color:#5f75b045;--callout-note-color:#698bcf;--callout-important-color:#9374c5;--callout-warning-color:#c99054;--callout-alert-color:#d35757;--callout-question-color:#5091b2;--callout-tip-color:#3ea06f}</style><link href=/main.css rel=stylesheet><script async data-website-id=01228822-c189-4b8a-93ba-733d045bf346 src=https://analytics.eu.umami.is/script.js></script><body class=post><script>if(localStorage.getItem('theme')=='dark'){document.body.classList.add('dark');const a=document.querySelector('link#hl');if(a)a.href='/hl-dark.css'}</script><header class=blur><div id=header-wrapper><nav><a href=/>The Data Quarry</a><button aria-label="toggle expand" class=separator id=toggler>::</button><span class="wrap left fold">{</span><a href=/posts>blog</a><span class="wrap-separator fold">,</span><a class=fold href=/talks>talks</a><span class="wrap-separator fold">,</span><a class=fold href=/projects>projects</a><span class="wrap right fold">} ;</span></nav><div id=btns><a rel="noreferrer noopener" aria-label=GitHub href=https://github.com/prrao87 target=_blank> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12" fill=currentColor></path></svg> </a><a rel="noreferrer noopener" aria-label=Twitter href=https://twitter.com/tech_optimist target=_blank> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><title>Twitter</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z" fill=currentColor></path></svg> </a><a rel="noreferrer noopener" aria-label=LinkedIn href=https://www.linkedin.com/in/prrao87 target=_blank> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z" fill=currentColor></path></svg> </a><a aria-label="Buy me a coffee" rel="noreferrer noopener" href=https://www.buymeacoffee.com/prrao87 target=_blank> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><title>Buy Me A Coffee</title><path d="M20.216 6.415l-.132-.666c-.119-.598-.388-1.163-1.001-1.379-.197-.069-.42-.098-.57-.241-.152-.143-.196-.366-.231-.572-.065-.378-.125-.756-.192-1.133-.057-.325-.102-.69-.25-.987-.195-.4-.597-.634-.996-.788a5.723 5.723 0 00-.626-.194c-1-.263-2.05-.36-3.077-.416a25.834 25.834 0 00-3.7.062c-.915.083-1.88.184-2.75.5-.318.116-.646.256-.888.501-.297.302-.393.77-.177 1.146.154.267.415.456.692.58.36.162.737.284 1.123.366 1.075.238 2.189.331 3.287.37 1.218.05 2.437.01 3.65-.118.299-.033.598-.073.896-.119.352-.054.578-.513.474-.834-.124-.383-.457-.531-.834-.473-.466.074-.96.108-1.382.146-1.177.08-2.358.082-3.536.006a22.228 22.228 0 01-1.157-.107c-.086-.01-.18-.025-.258-.036-.243-.036-.484-.08-.724-.13-.111-.027-.111-.185 0-.212h.005c.277-.06.557-.108.838-.147h.002c.131-.009.263-.032.394-.048a25.076 25.076 0 013.426-.12c.674.019 1.347.067 2.017.144l.228.031c.267.04.533.088.798.145.392.085.895.113 1.07.542.055.137.08.288.111.431l.319 1.484a.237.237 0 01-.199.284h-.003c-.037.006-.075.01-.112.015a36.704 36.704 0 01-4.743.295 37.059 37.059 0 01-4.699-.304c-.14-.017-.293-.042-.417-.06-.326-.048-.649-.108-.973-.161-.393-.065-.768-.032-1.123.161-.29.16-.527.404-.675.701-.154.316-.199.66-.267 1-.069.34-.176.707-.135 1.056.087.753.613 1.365 1.37 1.502a39.69 39.69 0 0011.343.376.483.483 0 01.535.53l-.071.697-1.018 9.907c-.041.41-.047.832-.125 1.237-.122.637-.553 1.028-1.182 1.171-.577.131-1.165.2-1.756.205-.656.004-1.31-.025-1.966-.022-.699.004-1.556-.06-2.095-.58-.475-.458-.54-1.174-.605-1.793l-.731-7.013-.322-3.094c-.037-.351-.286-.695-.678-.678-.336.015-.718.3-.678.679l.228 2.185.949 9.112c.147 1.344 1.174 2.068 2.446 2.272.742.12 1.503.144 2.257.156.966.016 1.942.053 2.892-.122 1.408-.258 2.465-1.198 2.616-2.657.34-3.332.683-6.663 1.024-9.995l.215-2.087a.484.484 0 01.39-.426c.402-.078.787-.212 1.074-.518.455-.488.546-1.124.385-1.766zm-1.478.772c-.145.137-.363.201-.578.233-2.416.359-4.866.54-7.308.46-1.748-.06-3.477-.254-5.207-.498-.17-.024-.353-.055-.47-.18-.22-.236-.111-.71-.054-.995.052-.26.152-.609.463-.646.484-.057 1.046.148 1.526.22.577.088 1.156.159 1.737.212 2.48.226 5.002.19 7.472-.14.45-.06.899-.13 1.345-.21.399-.072.84-.206 1.08.206.166.281.188.657.162.974a.544.544 0 01-.169.364zm-6.159 3.9c-.862.37-1.84.788-3.109.788a5.884 5.884 0 01-1.569-.217l.877 9.004c.065.78.717 1.38 1.5 1.38 0 0 1.243.065 1.658.065.447 0 1.786-.065 1.786-.065.783 0 1.434-.6 1.499-1.38l.94-9.95a3.996 3.996 0 00-1.322-.238c-.826 0-1.491.284-2.26.613z" fill=currentColor></path></svg> </a><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><div id=blank></div><aside class=blur><nav><ul><li><a class=h2 href=#how-rayon-rust-can-be-a-data-scientist-s-secret-weapon>How Rayon + Rust can be a data scientist’s secret weapon</a><li><a class=h2 href=#problem-statement>Problem statement</a><li><a class=h2 href=#background>Background</a><li><a class=h2 href=#iterators-and-closures-in-rust>Iterators and closures in Rust</a><li><a class=h2 href=#understanding-rayon-s-parallelism>Understanding Rayon’s parallelism</a> <ul><li><a class=h3 href=#parallel-iterators>Parallel iterators</a><li><a class=h3 href=#work-stealing>Work stealing</a></ul><li><a class=h2 href=#safety-guarantees-in-rust>Safety guarantees in Rust</a><li><a class=h2 href=#data-processing>Data processing</a> <ul><li><a class=h3 href=#python-and-multiprocessing>Python and multiprocessing</a><li><a class=h3 href=#rust-and-rayon>Rust and Rayon</a></ul><li><a class=h2 href=#comparing-performance>Comparing performance</a><li><a class=h2 href=#analysis>Analysis</a> <ul><li><a class=h3 href=#total-articles>Total articles</a><li><a class=h3 href=#articles-per-year>Articles per year</a><li><a class=h3 href=#highest-mean-female-pronoun-count>Highest mean female pronoun count</a></ul><li><a class=h2 href=#conclusions>Conclusions</a><li><a class=h2 href=#code>Code</a></ul></nav><button aria-label="back to top" id=back-to-top><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M11.9997 10.8284L7.04996 15.7782L5.63574 14.364L11.9997 8L18.3637 14.364L16.9495 15.7782L11.9997 10.8284Z" fill=currentColor></path></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1>Speeding up data analysis with Rayon and Rust</h1><div id=post-info><div id=date><span id=publish>2024-02-10</span></div><div id=tags><a href=https://thedataquarry.github.io/tags/rust><span>#</span>rust</a></div></div><h2 id=how-rayon-rust-can-be-a-data-scientist-s-secret-weapon>How Rayon + Rust can be a data scientist’s secret weapon<a aria-label="Anchor link for: how-rayon-rust-can-be-a-data-scientist-s-secret-weapon" class=zola-anchor href=#how-rayon-rust-can-be-a-data-scientist-s-secret-weapon>#</a></h2><p>Python is often the language used to analyze and explore data, and on many occasions, Python developers encounter performance bottlenecks when processing large datasets. In this post, I’ll highlight how a Rust implementation that uses the <a rel="nofollow noreferrer" href=https://github.com/rayon-rs/rayon>Rayon</a> crate makes parallelizing data processing <em>breathtakingly</em> simple in comparison to an equivalent Python implementation. I’ll also give a gentle introduction to the Rust concepts involved, and the type of parallelism that Rayon implements.<p>The results from this post are quite remarkable. The Rust implementation using Rayon is about 4x faster than Python, while also being more concise and readable than the Python version!<p><img alt src=https://thedataquarry.github.io/posts/intro-to-rayon/./rayon-vs-python-perf.png><p>Rayon is a very powerful and flexible framework, and this post only scratches the surface of what it can do. If you’re coming from Python, I hope this walkthrough will inspire you to explore Rayon, and the larger Rust ecosystem, much further. 🚀<blockquote class="callout warning"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M12.865 3.00017L22.3912 19.5002C22.6674 19.9785 22.5035 20.5901 22.0252 20.8662C21.8732 20.954 21.7008 21.0002 21.5252 21.0002H2.47266C1.92037 21.0002 1.47266 20.5525 1.47266 20.0002C1.47266 19.8246 1.51886 19.6522 1.60663 19.5002L11.1329 3.00017C11.4091 2.52187 12.0206 2.358 12.4989 2.63414C12.651 2.72191 12.7772 2.84815 12.865 3.00017ZM4.20471 19.0002H19.7932L11.9989 5.50017L4.20471 19.0002ZM10.9989 16.0002H12.9989V18.0002H10.9989V16.0002ZM10.9989 9.00017H12.9989V14.0002H10.9989V9.00017Z" fill=currentColor></path></svg></div><div class=content><p><strong>Note</strong><p>In practice, the interop between Python and Rust is greatly enhanced by <a rel="nofollow noreferrer" href=https://github.com/PyO3/pyo3>PyO3</a>, a framework that enables you to call Rust bindings from your Python code. This approach is heavily used by popular libraries like Pydantic, Polars and many others. Unifying Python and Rust workflows via PyO3 is a larger topic for a future blog post, so stay tuned!</div></blockquote><h2 id=problem-statement>Problem statement<a aria-label="Anchor link for: problem-statement" class=zola-anchor href=#problem-statement>#</a></h2><p>Let’s define a simple data analysis task that a Python data scientist might encounter. Say you want to roughly estimate the proportion of men and women mentioned in a large dataset of news articles. A simple heuristic is to count the number of times gendered pronouns in English (<em>he, him, his, she, her, hers</em>) appear in each article’s text. This is a very naive and crude approach to analyzing gender balance – it only works in English and potentially misses a lot of mentions that don’t use pronouns – but it’s at least a starting point to make sense of the data at hand.<p>We’ll use the <em><a rel="nofollow noreferrer" href=https://www.kaggle.com/datasets/snapcrack/all-the-news>All the news</a></em> dataset from Kaggle, which contains 143,000 news articles from 15 American publications. The dataset is made available on Kaggle as three separate CSV files, <code>articles1.csv</code>, <code>articles2.csv</code> and <code>articles3.csv</code>.<p>As you can imagine, processing each article in a sequential fashion to extract and count pronouns is not only slow – it’s also rather wasteful because it only exploits one CPU core to process the data when your machine likely has multiple cores that are underutilized. In reality, each core (and its associated threads) can process a different article at the same time. This can be viewed as an <em>embarrassingly parallel</em> problem, where each article can be processed independently of the others.<p>It’s typical in these scenarios to tokenize the text of each article and then count the occurrences of specific tokens. However, because pronouns are the <em>only</em> tokens we care about in this case, it becomes a simple pattern matching problem and we can just use regular expressions (skipping tokenization entirely).<p>This is best illustrated with an example.<blockquote><p><strong>She</strong> says that <strong>she’s</strong> going to be late to <strong>his</strong> place.</blockquote><p>For the text above, we can apply a regex to match occurrences of gendered pronouns, replacing word contractions like “she’s” with the expanded form “she is”, and then count the number of matches. The result in this case is 1 male pronoun and 2 female pronouns. The goal is thus to apply this method on the text of every article in the dataset, and to do so as efficiently and quickly as possible.<h2 id=background>Background<a aria-label="Anchor link for: background" class=zola-anchor href=#background>#</a></h2><p>If you’ve been keeping up with the pace of innovation in ML and data science tooling lately, you’ve probably noticed that more Python packages are powered by Rust, and for good reason. Rust is a systems programming language that runs blazingly fast, offers memory safety without a garbage collector, and guarantees thread safety at compile-time. CPU-hungry libraries like Hugging Face’s <a rel="nofollow noreferrer" href=https://github.com/huggingface/tokenizers>tokenizers</a> are a testament to this, having long understood these benefits, and are written almost entirely in Rust.<p>Python users well know that their language is just <em>not</em> suited to tasks involving parallelism and concurrency. For CPU-intensive tasks, you can use modules like <code>multiprocessing</code> and <code>concurrent.futures.ProcessPoolExecutor</code> that exploit multiple cores to an extent, but building such pipelines can be surprisingly tedious. The onus is on the developer to select the right number of CPU workers, manage batches of data and handle errors.<p>As mentioned above, Rust has a fantastic crate called Rayon for data parallelism<sup class=footnote-reference><a href=#1>1</a></sup>. Rust is known for its relatively steep learning curve, and there’s no denying that it’s more complex than Python to get started with. But Rayon is a great example of how a perfect level of abstraction on top of a language’s core features can make complex tasks like parallelism much more accessible to developers.<p>Even if you’ve not written a lot of Rust before, you can quickly become proficient enough with Rayon to massively speed up certain data processing tasks without worrying about lower-level primitives like threads, locks, mutexes and so on. If you read the <a rel="nofollow noreferrer" href=https://github.com/huggingface/tokenizers/blob/c893204c45d7f2cd66958731dd7779548ca54ad5/tokenizers/src/utils/parallelism.rs>source code</a> of libraries like <code>tokenizers</code>, you’ll see that it uses more complex Rust concepts like lifetimes, traits and generics, but this post will highlight how you can get a LOT out of Rayon without needing to get into those. As is common with most things in Rust, <strong>start simply and build up from there!</strong> You do not need to be an expert in the language to use it productively. 😇<h2 id=iterators-and-closures-in-rust>Iterators and closures in Rust<a aria-label="Anchor link for: iterators-and-closures-in-rust" class=zola-anchor href=#iterators-and-closures-in-rust>#</a></h2><p>This section will go over two important Rust concepts that are needed to follow along with the code shown below. If you’re already familiar with iterator and closure syntax in Rust, feel free to skip ahead to the next section.<p>In idiomatic Rust, for loops are not as common as in Python, and are often replaced by iterators, which are used to process collections of data in a functional style. Consider the below example of squaring each element of a vector of integers.<pre class=language-rs data-lang=rs style=background:#2e3440;color:#d8dee9><code class=language-rs data-lang=rs><span style=color:#616e88>// 1. For loop
</span><span style=color:#81a1c1>let</span><span> nums </span><span style=color:#81a1c1>= </span><span>vec![</span><span style=color:#b48ead>1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>2</span><span style=color:#eceff4>, </span><span style=color:#b48ead>3</span><span style=color:#eceff4>, </span><span style=color:#b48ead>4</span><span style=color:#eceff4>, </span><span style=color:#b48ead>5</span><span style=color:#eceff4>, </span><span style=color:#b48ead>6</span><span style=color:#eceff4>, </span><span style=color:#b48ead>7</span><span style=color:#eceff4>, </span><span style=color:#b48ead>8</span><span style=color:#eceff4>, </span><span style=color:#b48ead>9</span><span style=color:#eceff4>, </span><span style=color:#b48ead>10</span><span>]</span><span style=color:#eceff4>;
</span><span style=color:#81a1c1>let mut</span><span> nums_squared</span><span style=color:#eceff4>: </span><span style=color:#8fbcbb>Vec</span><span><</span><span style=color:#81a1c1>i32</span><span>> </span><span style=color:#81a1c1>= </span><span style=color:#8fbcbb>Vec</span><span style=color:#81a1c1>::</span><span>new()</span><span style=color:#eceff4>;
</span><span style=color:#81a1c1>for</span><span> num </span><span style=color:#81a1c1>in</span><span> nums {
</span><span>    nums_squared</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>push</span><span>(num</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>pow</span><span>(</span><span style=color:#b48ead>2</span><span>))</span><span style=color:#eceff4>;
</span><span>}
</span></code></pre><p>The for loop version will seem familiar to Python developers. Note that we need to declare <code>nums_squared</code> as mutable because we’re modifying it inside the loop. The <code>push</code> method is used to add elements to the vector.<pre class=language-rs data-lang=rs style=background:#2e3440;color:#d8dee9><code class=language-rs data-lang=rs><span style=color:#616e88>// 2. Iterator
</span><span style=color:#81a1c1>let</span><span> nums </span><span style=color:#81a1c1>= </span><span>vec![</span><span style=color:#b48ead>1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>2</span><span style=color:#eceff4>, </span><span style=color:#b48ead>3</span><span style=color:#eceff4>, </span><span style=color:#b48ead>4</span><span style=color:#eceff4>, </span><span style=color:#b48ead>5</span><span style=color:#eceff4>, </span><span style=color:#b48ead>6</span><span style=color:#eceff4>, </span><span style=color:#b48ead>7</span><span style=color:#eceff4>, </span><span style=color:#b48ead>8</span><span style=color:#eceff4>, </span><span style=color:#b48ead>9</span><span style=color:#eceff4>, </span><span style=color:#b48ead>10</span><span>]</span><span style=color:#eceff4>;
</span><span style=color:#81a1c1>let</span><span> nums_squared</span><span style=color:#eceff4>: </span><span style=color:#8fbcbb>Vec</span><span><</span><span style=color:#81a1c1>i32</span><span>> </span><span style=color:#81a1c1>=</span><span> nums
</span><span>    </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>iter</span><span>()
</span><span>    </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>map</span><span>(|</span><span style=color:#81a1c1>&</span><span>x| x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>pow</span><span>(</span><span style=color:#b48ead>2</span><span>))
</span><span>    </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>collect</span><span>()</span><span style=color:#eceff4>;
</span></code></pre><p>The iterator version first converts the input vector to an iterator via the <code>.iter()</code> method. It then uses a common method in functional programming, <code>map</code>, to apply a squaring function to each element of the <code>nums</code> vector, and then uses the <code>collect</code> method to collect the results into a new vector. The squaring is done via a closure, which is an anonymous function in Rust, kind of analogous to lambda functions in Python. The syntax <code>|&x| x.pow(2)</code> is a closure that takes a <em>reference</em> to an integer <code>x</code> (i.e., it borrows the owned value of <code>x</code>) and returns the integer raised to a power of 2.<p>Rust has a strict borrow-checker and ownership system, so it’s worth spending a bit of time to understand how these work (but there’s no need to go too deep when you’re just getting started).<h2 id=understanding-rayon-s-parallelism>Understanding Rayon’s parallelism<a aria-label="Anchor link for: understanding-rayon-s-parallelism" class=zola-anchor href=#understanding-rayon-s-parallelism>#</a></h2><p>Now that it’s clear how to use iterators and closures in Rust, we can dig a little deeper into how Rayon uses these constructs, and more, to achieve parallelism.<h3 id=parallel-iterators>Parallel iterators<a aria-label="Anchor link for: parallel-iterators" class=zola-anchor href=#parallel-iterators>#</a></h3><p>The main user-facing abstraction in Rayon is the <code>par_iter</code> method, which stands for parallel iterator. The idea is that a program that uses a sequential iterator can be easily converted to use a parallel iterator by simply replacing <code>iter</code> with <code>par_iter</code>.<p>Under the hood, parallel iterators rely on a core primitive called <code>join</code> that allows Rayon to potentially execute two closures in parallel and bring their results together once they both finish. The remarkable feature is that Rayon <em>itself</em> (and not the user) decides whether or not parallelism is beneficial, and if so, how to divide the work among threads.<p>This is an example of how simple it is to use a parallel iterator in Rayon.<pre class=language-rs data-lang=rs style=background:#2e3440;color:#d8dee9><code class=language-rs data-lang=rs><mark style=background:#434c5e52><span style=color:#81a1c1>use </span><span>rayon</span><span style=color:#81a1c1>::</span><span>prelude</span><span style=color:#81a1c1>::*</span><span style=color:#eceff4>;
</span></mark><span>
</span><span style=color:#616e88>// 3. Parallel iterator
</span><span style=color:#81a1c1>let</span><span> nums </span><span style=color:#81a1c1>= </span><span>vec![</span><span style=color:#b48ead>1</span><span style=color:#eceff4>, </span><span style=color:#b48ead>2</span><span style=color:#eceff4>, </span><span style=color:#b48ead>3</span><span style=color:#eceff4>, </span><span style=color:#b48ead>4</span><span style=color:#eceff4>, </span><span style=color:#b48ead>5</span><span style=color:#eceff4>, </span><span style=color:#b48ead>6</span><span style=color:#eceff4>, </span><span style=color:#b48ead>7</span><span style=color:#eceff4>, </span><span style=color:#b48ead>8</span><span style=color:#eceff4>, </span><span style=color:#b48ead>9</span><span style=color:#eceff4>, </span><span style=color:#b48ead>10</span><span>]</span><span style=color:#eceff4>;
</span><span style=color:#81a1c1>let</span><span> nums_squared</span><span style=color:#eceff4>: </span><span style=color:#8fbcbb>Vec</span><span><</span><span style=color:#81a1c1>i32</span><span>> </span><span style=color:#81a1c1>=</span><span> nums
</span><mark style=background:#434c5e52><span>    </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>par_iter</span><span>()
</span></mark><span>    </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>map</span><span>(|</span><span style=color:#81a1c1>&</span><span>x| x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>pow</span><span>(</span><span style=color:#b48ead>2</span><span>))
</span><span>    </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>collect</span><span>()</span><span style=color:#eceff4>;
</span></code></pre><p>All you do is replace the sequential <code>iter</code> with the parallel <code>par_iter</code> and Rayon takes care of handling the lower level primitives. It’s that simple!<p>Under the hood, parallel iterators apply a divide-and-conquer strategy to the task at hand. In the example above, the parallel iterator initiated by the call to <code>par_iter</code> will spawn two threads that implement a <code>join</code>, dividing the work into two halves. The worker thread in charge of either half continues to divide the work further until a sufficiently small amount of work is left to be done, which is then executed sequentially. This can be visualized as follows:<p><img alt src=https://thedataquarry.github.io/posts/intro-to-rayon/./rayon-divide-and-conquer.png><p>Note that Rayon starts with roughly one worker thread per CPU core – not all steps in the parallel iterator pipeline will spawn new threads. The worker threads instead create <em>tasks</em> that are sent to the <code>join</code> operation. A limited pool of worker threads shares a common pool of tasks, with a dynamic scheduling strategy that exploits the available resources to the fullest.<h3 id=work-stealing>Work stealing<a aria-label="Anchor link for: work-stealing" class=zola-anchor href=#work-stealing>#</a></h3><p>The idea of work stealing is not new, nor is it unique to Rayon. It’s in fact from a body of research in parallel program execution that goes back decades. Rayon’s implementation is based on the method described in a paper by Blumofe and Leiserson<sup class=footnote-reference><a href=#2>2</a></sup>. In the paper, the authors compare and contrast work <em>stealing</em> with work <em>sharing</em>, and show that work stealing is provably more efficient.<p>In a nutshell, work sharing involves a scheduler that assigns tasks to new worker threads whenever they are spawned, migrating the work to underutilized threads. In contrast, work stealing, which is implemented by Rayon, is more proactive, where the underutilized threads themselves take initiative and “steal” unfinished work from other threads. Intuitively, this results in less migration of tasks and communication overhead leading to better performance.<p>Rayon implements an adaptive “thief-splitting” <a rel="nofollow noreferrer" href=https://github.com/rayon-rs/rayon/pull/106>algorithm</a> when using <code>par_iter</code> that dynamically splits the work into enough jobs that fill every available thread. Whenever a job is stolen, that job will again be split such that there is enough work for every thread. The beauty of this approach is that it considers real-time factors like the number of threads, the amount of work left to be done, how idle or busy the threads are, etc., and so the execution varies how much parallelization is active at any given point. However, the user doesn’t need to care about the lower level details at any point.<blockquote class="callout tip"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M9.97308 18H11V13H13V18H14.0269C14.1589 16.7984 14.7721 15.8065 15.7676 14.7226C15.8797 14.6006 16.5988 13.8564 16.6841 13.7501C17.5318 12.6931 18 11.385 18 10C18 6.68629 15.3137 4 12 4C8.68629 4 6 6.68629 6 10C6 11.3843 6.46774 12.6917 7.31462 13.7484C7.40004 13.855 8.12081 14.6012 8.23154 14.7218C9.22766 15.8064 9.84103 16.7984 9.97308 18ZM10 20V21H14V20H10ZM5.75395 14.9992C4.65645 13.6297 4 11.8915 4 10C4 5.58172 7.58172 2 12 2C16.4183 2 20 5.58172 20 10C20 11.8925 19.3428 13.6315 18.2443 15.0014C17.624 15.7748 16 17 16 18.5V21C16 22.1046 15.1046 23 14 23H10C8.89543 23 8 22.1046 8 21V18.5C8 17 6.37458 15.7736 5.75395 14.9992Z" fill=currentColor></path></svg></div><div class=content><p>In summary, a combination of <strong>parallel iterators</strong>, <strong>work stealing</strong> and the right level of user-facing <strong>abstraction</strong> make Rayon such a fantastic tool for data parallelism.</div></blockquote><h2 id=safety-guarantees-in-rust>Safety guarantees in Rust<a aria-label="Anchor link for: safety-guarantees-in-rust" class=zola-anchor href=#safety-guarantees-in-rust>#</a></h2><p>Rayon inherits all the safety guarantees that Rust provides. From a memory safety perspective, Rust’s ownership and borrowing system ensures that no data races occur and that no two threads can modify the same data at the same time. When coupled with Rust’s powerful generics and type system, the result is that the framework properly abstracts away the hard parts of parallelism, allowing the developer to focus on the program’s logic.<p>Most importantly, the ever-watchful Rust compiler enforces these checks at compile time, meaning that the kinds of errors that commonly plague parallel programs are caught before the program even runs. This is in stark contrast to other systems languages, where subtle data access bugs can lead to hard-to-debug errors during runtime.<h2 id=data-processing>Data processing<a aria-label="Anchor link for: data-processing" class=zola-anchor href=#data-processing>#</a></h2><p>We can now address the problem at hand – capturing and counting gendered pronouns in the news articles dataset!<h3 id=python-and-multiprocessing>Python and multiprocessing<a aria-label="Anchor link for: python-and-multiprocessing" class=zola-anchor href=#python-and-multiprocessing>#</a></h3><p>In Python, we can begin by loading the CSV file’s contents into a list of records. We first need to clean the text by expanding word contractions (like “he’s” to “he is”) and then remove punctuation and other non-alphabetic characters.<pre class=language-py data-lang=py style=background:#2e3440;color:#d8dee9><code class=language-py data-lang=py><span style=color:#81a1c1>import </span><span>re
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>clean_text</span><span>(text</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>str</span><span>) </span><span style=color:#eceff4>-> </span><span style=color:#81a1c1>str</span><span>:
</span><span>    text_lower </span><span style=color:#81a1c1>= </span><span>text</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>lower</span><span>()
</span><span>    suffix_mapping </span><span style=color:#81a1c1>= </span><span>{
</span><span>        </span><span style=color:#a3be8c>"s"</span><span style=color:#eceff4>: </span><span style=color:#a3be8c>" is"</span><span style=color:#eceff4>,
</span><span>        </span><span style=color:#a3be8c>"d"</span><span style=color:#eceff4>: </span><span style=color:#a3be8c>" had"</span><span style=color:#eceff4>,
</span><span>        </span><span style=color:#a3be8c>"ll"</span><span style=color:#eceff4>: </span><span style=color:#a3be8c>" will"</span><span style=color:#eceff4>,
</span><span>    }
</span><span>    </span><span style=color:#616e88># Replace contractions with full words
</span><span>    formatted_text </span><span style=color:#81a1c1>= </span><span>re</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>sub</span><span>(</span><span style=color:#81a1c1>r</span><span style=color:#a3be8c>"(</span><span>[’']</span><span style=color:#a3be8c>)(s</span><span style=color:#81a1c1>|</span><span style=color:#a3be8c>d</span><span style=color:#81a1c1>|</span><span style=color:#a3be8c>ll)"</span><span style=color:#eceff4>, </span><span style=color:#81a1c1>lambda </span><span>x: suffix_mapping[x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>group</span><span>(</span><span style=color:#b48ead>2</span><span>)]</span><span style=color:#eceff4>, </span><span>text_lower)
</span><span>    </span><span style=color:#616e88># Remove non-alphabetic characters
</span><span>    result </span><span style=color:#81a1c1>= </span><span>re</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>sub</span><span>(</span><span style=color:#81a1c1>r</span><span style=color:#a3be8c>"</span><span>[</span><span style=color:#81a1c1>^</span><span>a-zA-Z\s]</span><span style=color:#a3be8c>"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>""</span><span style=color:#eceff4>, </span><span>formatted_text)
</span><span>    </span><span style=color:#81a1c1>return </span><span>result
</span></code></pre><p>In the above function, we simultaneously match multiple patterns using a mapping via a lambda function. The <code>x.group(2)</code> syntax denotes the second capture group in the regex match, which is the suffix of the contraction, which is then looked up in the <code>suffix_mapping</code> dictionary via the lambda function.<p>Counting the pronouns is an easy job, where we check for the presence of each token in the list of pronouns and increment the count by 1 each time it’s found. The <code>calculate_counts</code> function is then applied to each record in the dataset to calculate the counts at an article level, which we can then write to a new CSV file.<pre class=language-py data-lang=py style=background:#2e3440;color:#d8dee9><code class=language-py data-lang=py><span style=color:#81a1c1>def </span><span style=color:#88c0d0>count_gendered_pronouns</span><span>(tokens</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>list</span><span>[</span><span style=color:#81a1c1>str</span><span>]) </span><span style=color:#eceff4>-> </span><span style=color:#81a1c1>tuple</span><span>[</span><span style=color:#81a1c1>int</span><span>, </span><span style=color:#81a1c1>int</span><span>]:
</span><span>    num_male_pronouns </span><span style=color:#81a1c1>= </span><span style=font-style:italic;color:#88c0d0>sum</span><span>(</span><span style=color:#b48ead>1 </span><span style=color:#81a1c1>for </span><span>token </span><span style=color:#81a1c1>in </span><span>tokens </span><span style=color:#81a1c1>if </span><span>token </span><span style=color:#81a1c1>in </span><span>[</span><span style=color:#a3be8c>"he"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"him"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"his"</span><span>])
</span><span>    num_female_pronouns </span><span style=color:#81a1c1>= </span><span style=font-style:italic;color:#88c0d0>sum</span><span>(</span><span style=color:#b48ead>1 </span><span style=color:#81a1c1>for </span><span>token </span><span style=color:#81a1c1>in </span><span>tokens </span><span style=color:#81a1c1>if </span><span>token </span><span style=color:#81a1c1>in </span><span>[</span><span style=color:#a3be8c>"she"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"her"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"hers"</span><span>])
</span><span>    </span><span style=color:#81a1c1>return </span><span>num_male_pronouns, num_female_pronouns
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>calculate_counts</span><span>(data</span><span style=color:#eceff4>: </span><span>JsonBlob) </span><span style=color:#eceff4>-> </span><span>JsonBlob:
</span><span>    text </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>clean_text</span><span>(data[</span><span style=color:#a3be8c>"content"</span><span>])
</span><span>    tokens </span><span style=color:#81a1c1>= </span><span>result</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>split</span><span>()
</span><span>    data[</span><span style=color:#a3be8c>"num_male_pronouns"</span><span>], data[</span><span style=color:#a3be8c>"num_female_pronouns"</span><span>] </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>count_gendered_pronouns</span><span>(tokens)
</span><span>    data</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>pop</span><span>(</span><span style=color:#a3be8c>"content"</span><span>)
</span><span>    </span><span style=color:#81a1c1>return </span><span>data
</span></code></pre><p>How is all this parallelized? We can design some multiprocessing logic that exploits multiple CPU cores to process the data. Conceptually, it looks something like this:<p><img alt src=https://thedataquarry.github.io/posts/intro-to-rayon/./parallelism-python-approach.png><p>In the figure above, only two worker processes are shown, but in reality, the number of worker processes can be set to the number of CPU cores available.<p>The code to perform the operation via multiprocessing in Python is shown below.<pre class=language-py data-lang=py style=background:#2e3440;color:#d8dee9><code class=language-py data-lang=py><span style=color:#81a1c1>from </span><span>typing </span><span style=color:#81a1c1>import </span><span>Iterator
</span><span style=color:#81a1c1>from </span><span>concurrent</span><span style=color:#81a1c1>.</span><span>futures </span><span style=color:#81a1c1>import </span><span>ProcessPoolExecutor
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>create_batches</span><span>(data</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>list</span><span>[JsonBlob]) </span><span style=color:#eceff4>-> </span><span>Iterator[</span><span style=color:#81a1c1>list</span><span>[JsonBlob]]:
</span><span>    </span><span style=color:#616e88>"""Yield batches of data of the specified size"""
</span><span>    </span><span style=color:#81a1c1>for </span><span>i </span><span style=color:#81a1c1>in </span><span style=font-style:italic;color:#88c0d0>range</span><span>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>, </span><span style=font-style:italic;color:#88c0d0>len</span><span>(data)</span><span style=color:#eceff4>, </span><span style=color:#81a1c1>self.</span><span>batch_size):
</span><span>        </span><span style=color:#81a1c1>yield </span><span>data[i </span><span style=color:#eceff4>: </span><span>i </span><span style=color:#81a1c1>+ self.</span><span>batch_size]
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>process_batches</span><span>(data</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>list</span><span>[JsonBlob]) </span><span style=color:#eceff4>-> </span><span style=color:#81a1c1>list</span><span>[JsonBlob]:
</span><span>    </span><span style=color:#81a1c1>with </span><span style=color:#88c0d0>ProcessPoolExecutor</span><span>(max_workers</span><span style=color:#81a1c1>=NUM_WORKERS</span><span>) </span><span style=color:#81a1c1>as </span><span>executor:
</span><span>        </span><span style=color:#616e88># Batch up the data
</span><span>        batches </span><span style=color:#81a1c1>= list</span><span>(</span><span style=color:#88c0d0>create_batches</span><span>(data))
</span><span>        </span><span style=color:#616e88># Process batches in parallel
</span><span>        results </span><span style=color:#81a1c1>= </span><span>[]
</span><span>        </span><span style=color:#81a1c1>for </span><span>batch </span><span style=color:#81a1c1>in </span><span>batches:
</span><span>            batch_results </span><span style=color:#81a1c1>= list</span><span>(executor</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>map</span><span>(</span><span style=color:#81a1c1>self.</span><span>calculate_counts</span><span style=color:#eceff4>, </span><span>batch))
</span><span>            results</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>extend</span><span>(batch_results)
</span><span>        </span><span style=color:#81a1c1>return </span><span>results
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>main</span><span>(files</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>list</span><span>[Path]) </span><span style=color:#eceff4>-> </span><span style=color:#81a1c1>None</span><span>:
</span><span>    </span><span style=color:#81a1c1>for </span><span>input_file </span><span style=color:#81a1c1>in </span><span>files:
</span><span>        records </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>load_csv</span><span>(input_file)
</span><span>        results </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>process_batches</span><span>(records)
</span><span>        output_file </span><span style=color:#81a1c1>= </span><span>input_file</span><span style=color:#81a1c1>.</span><span>name</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>replace</span><span>(</span><span style=color:#a3be8c>".csv"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"_processed.csv"</span><span>)
</span><span>        </span><span style=color:#88c0d0>write_results</span><span>(results</span><span style=color:#eceff4>, </span><span>file_path</span><span style=color:#eceff4>, </span><span>output_file)
</span></code></pre><p>We manually divide the data into batches, and pass the batched data to the <code>ProcessPoolExecutor</code>, which assigns each batch of data to a worker process.<p>The complete code for the Python implementation can be found <a rel="nofollow noreferrer" href=https://github.com/thedataquarry/rustinpieces/tree/main/src/parallelism/python>here</a>.<h3 id=rust-and-rayon>Rust and Rayon<a aria-label="Anchor link for: rust-and-rayon" class=zola-anchor href=#rust-and-rayon>#</a></h3><p>The Rust code and logic is <em>really</em> straightforward in comparison, and it’s a testament to the expressivity of the language as well as the design of the library.<pre class=language-rs data-lang=rs style=background:#2e3440;color:#d8dee9><code class=language-rs data-lang=rs><span style=color:#81a1c1>fn </span><span style=color:#88c0d0>clean_text</span><span>(text</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>&str</span><span>) </span><span style=color:#eceff4>-></span><span> String {
</span><span>    </span><span style=color:#81a1c1>let</span><span> pattern1 </span><span style=color:#81a1c1>= </span><span>Regex</span><span style=color:#81a1c1>::</span><span>new(</span><span style=color:#81a1c1>r</span><span style=color:#a3be8c>"([’'])(s|d|ll)"</span><span>)</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>unwrap</span><span>()</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#616e88>// Replace pattern with text
</span><span>    </span><span style=color:#81a1c1>let</span><span> matched </span><span style=color:#81a1c1>=</span><span> pattern1</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>replace_all</span><span>(text</span><span style=color:#eceff4>, </span><span>|capture</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>&</span><span>Captures| </span><span style=color:#81a1c1>match &</span><span>capture[</span><span style=color:#b48ead>2</span><span>] {
</span><span>        </span><span style=color:#a3be8c>"s" </span><span style=color:#81a1c1>=> </span><span style=color:#a3be8c>" is"</span><span style=color:#eceff4>,
</span><span>        </span><span style=color:#a3be8c>"d" </span><span style=color:#81a1c1>=> </span><span style=color:#a3be8c>" had"</span><span style=color:#eceff4>,
</span><span>        </span><span style=color:#a3be8c>"ll" </span><span style=color:#81a1c1>=> </span><span style=color:#a3be8c>" will"</span><span style=color:#eceff4>,
</span><span>        </span><span style=color:#81a1c1>_ => </span><span style=color:#a3be8c>"&LTunk>"</span><span style=color:#eceff4>,
</span><span>    })</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#616e88>// Remove non-alphabetic characters
</span><span>    </span><span style=color:#81a1c1>let</span><span> pattern2 </span><span style=color:#81a1c1>= </span><span>Regex</span><span style=color:#81a1c1>::</span><span>new(</span><span style=color:#81a1c1>r</span><span style=color:#a3be8c>"[^a-zA-Z\s]"</span><span>)</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>unwrap</span><span>()</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> clean_text </span><span style=color:#81a1c1>=</span><span> pattern2</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>replace_all</span><span>(</span><span style=color:#81a1c1>&</span><span>matched</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>""</span><span>)</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> result</span><span style=color:#eceff4>: </span><span style=color:#8fbcbb>String </span><span style=color:#81a1c1>=</span><span> clean_text</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>to_lowercase</span><span>()</span><span style=color:#eceff4>;
</span><span>    result
</span><span>}
</span></code></pre><p>The regex matching and replacement is done with the same patterns as in Python. The key difference here is how we use a <code>match</code> statement to replace multiple patterns using a single closure. The <code>&capture[2]</code> syntax is used to access the second capture group in the regex match, which is the suffix of the contraction, and this is then passed to the match statement.<p>The parallelization logic is where the magic happens. Because Rayon implements parallel iterators, we can actually perform <em>multiple</em> parallel computations at two levels – first, at the level of the articles, and then at the level of the tokens in each article. This is a very natural way to think about divide-and-conquer problems, and shows how powerful the <code>par_iter</code> abstraction is.<pre class=language-rs data-lang=rs style=background:#2e3440;color:#d8dee9><code class=language-rs data-lang=rs><span style=color:#81a1c1>fn </span><span style=color:#88c0d0>count_gendered_pronouns</span><span>(tokens</span><span style=color:#eceff4>: </span><span style=color:#8fbcbb>Vec</span><span><</span><span style=color:#81a1c1>&str</span><span>>) </span><span style=color:#eceff4>-> </span><span>(</span><span style=color:#81a1c1>usize</span><span>, </span><span style=color:#81a1c1>usize</span><span>) {
</span><span>    </span><span style=color:#81a1c1>let</span><span> num_male_pronouns </span><span style=color:#81a1c1>=</span><span> tokens
</span><mark style=background:#434c5e52><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>par_iter</span><span>()
</span></mark><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>filter</span><span>(|</span><span style=color:#81a1c1>&</span><span>x| </span><span style=color:#81a1c1>*</span><span>x </span><span style=color:#81a1c1>== </span><span style=color:#a3be8c>"he" </span><span style=color:#81a1c1>|| *</span><span>x </span><span style=color:#81a1c1>== </span><span style=color:#a3be8c>"him" </span><span style=color:#81a1c1>|| *</span><span>x </span><span style=color:#81a1c1>== </span><span style=color:#a3be8c>"his"</span><span>)
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>count</span><span>()</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> num_female_pronouns </span><span style=color:#81a1c1>=</span><span> tokens
</span><mark style=background:#434c5e52><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>par_iter</span><span>()
</span></mark><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>filter</span><span>(|</span><span style=color:#81a1c1>&</span><span>x| </span><span style=color:#81a1c1>*</span><span>x </span><span style=color:#81a1c1>== </span><span style=color:#a3be8c>"she" </span><span style=color:#81a1c1>|| *</span><span>x </span><span style=color:#81a1c1>== </span><span style=color:#a3be8c>"her" </span><span style=color:#81a1c1>|| *</span><span>x </span><span style=color:#81a1c1>== </span><span style=color:#a3be8c>"hers"</span><span>)
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>count</span><span>()</span><span style=color:#eceff4>;
</span><span>    (num_male_pronouns</span><span style=color:#eceff4>,</span><span> num_female_pronouns)
</span><span>}
</span></code></pre><p>The code above shows how just two lines of code changed from <code>iter()</code> to <code>par_iter()</code> can make the computation parallel. The <code>filter</code> method is used to filter the tokens that match the pronouns, and the <code>count</code> method is used to count the number of matches. This stage of the computation produces the pronoun counts for each article.<pre class=language-rs data-lang=rs style=background:#2e3440;color:#d8dee9><code class=language-rs data-lang=rs><span style=color:#81a1c1>fn </span><span style=color:#88c0d0>process_record</span><span>(record</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>&</span><span>Record) </span><span style=color:#eceff4>-></span><span> RecordProcessed {
</span><span>    </span><span style=color:#81a1c1>let</span><span> text </span><span style=color:#81a1c1>= &</span><span>record</span><span style=color:#81a1c1>.</span><span>content</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> result</span><span style=color:#eceff4>: </span><span style=color:#8fbcbb>String </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>clean_text</span><span>(text)</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let</span><span> tokens</span><span style=color:#eceff4>: </span><span style=color:#8fbcbb>Vec</span><span><</span><span style=color:#81a1c1>&str</span><span>> </span><span style=color:#81a1c1>=</span><span> result</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>split_whitespace</span><span>()</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>collect</span><span>()</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let </span><span>(n_m</span><span style=color:#eceff4>,</span><span> n_f) </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>count_gendered_pronouns</span><span>(tokens)</span><span style=color:#eceff4>;
</span><span>    RecordProcessed {
</span><span>        id</span><span style=color:#eceff4>:</span><span> record</span><span style=color:#81a1c1>.</span><span>id</span><span style=color:#eceff4>,
</span><span>        publication</span><span style=color:#eceff4>:</span><span> record</span><span style=color:#81a1c1>.</span><span>publication</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>to_string</span><span>()</span><span style=color:#eceff4>,
</span><span>        author</span><span style=color:#eceff4>:</span><span> record</span><span style=color:#81a1c1>.</span><span>author</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>to_string</span><span>()</span><span style=color:#eceff4>,
</span><span>        date</span><span style=color:#eceff4>:</span><span> record</span><span style=color:#81a1c1>.</span><span>date</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>to_string</span><span>()</span><span style=color:#eceff4>,
</span><span>        num_male_pronouns</span><span style=color:#eceff4>:</span><span> n_m</span><span style=color:#eceff4>,
</span><span>        num_female_pronouns</span><span style=color:#eceff4>:</span><span> n_f</span><span style=color:#eceff4>,
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#81a1c1>fn </span><span style=color:#88c0d0>main</span><span>(input_path</span><span style=color:#eceff4>: </span><span style=color:#81a1c1>&</span><span>PathBuf) {
</span><span>    </span><span style=color:#81a1c1>let</span><span> data </span><span style=color:#81a1c1>= </span><span style=color:#88c0d0>load_csv</span><span>(Path</span><span style=color:#81a1c1>::</span><span>new(input_path))</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>unwrap</span><span>()</span><span style=color:#eceff4>;
</span><mark style=background:#434c5e52><span>    </span><span style=color:#81a1c1>let</span><span> records </span><span style=color:#81a1c1>=</span><span> data</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>par_iter</span><span>()</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>map</span><span>(process_record)</span><span style=color:#81a1c1>.</span><span>collect</span><span style=color:#81a1c1>::</span><span><</span><span style=color:#8fbcbb>Vec</span><span><</span><span style=color:#81a1c1>_</span><span>>>()</span><span style=color:#eceff4>;
</span></mark><span>    </span><span style=color:#616e88>// ... Convert the output paths to strings prior to replacement
</span><span>    </span><span style=color:#81a1c1>let</span><span> output_path </span><span style=color:#81a1c1>=</span><span> output_path</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>replace</span><span>(</span><span style=color:#a3be8c>".csv"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"_processed.csv"</span><span>)</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>let mut</span><span> wtr </span><span style=color:#81a1c1>= </span><span>csv</span><span style=color:#81a1c1>::</span><span>Writer</span><span style=color:#81a1c1>::</span><span>from_path(Path</span><span style=color:#81a1c1>::</span><span>new(</span><span style=color:#81a1c1>&</span><span>output_path))</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>unwrap</span><span>()</span><span style=color:#eceff4>;
</span><span>    </span><span style=color:#81a1c1>_ =</span><span> records</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>iter</span><span>()</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>map</span><span>(|x| wtr</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>serialize</span><span>(x))</span><span style=color:#81a1c1>.</span><span>collect</span><span style=color:#81a1c1>::</span><span><</span><span style=color:#8fbcbb>Vec</span><span><</span><span style=color:#81a1c1>_</span><span>>>()</span><span style=color:#eceff4>;
</span><span>}
</span></code></pre><p>To collect all the article results prior to writing to CSV, we can apply another <code>par_iter</code> call, where we process the entire set of articles in parallel. There’s no need to manually divide the data into batches, and no need to manage worker processes. Rayon takes care of all of this for us through its work-stealing scheduler. 😎<p>The complete code for the Rust implementation can be found <a rel="nofollow noreferrer" href=https://github.com/thedataquarry/rustinpieces/tree/main/src/parallelism/rust>here</a>.<h2 id=comparing-performance>Comparing performance<a aria-label="Anchor link for: comparing-performance" class=zola-anchor href=#comparing-performance>#</a></h2><p>The Python and Rust implementations were run on the full dataset of 143,000 records to see how the performance scales to realistic sizes of data. The results are shown in the table below.<table><thead><tr><th>Records<th>Python (sec)<th>Rust (sec)<th>Speedup factor<tbody><tr><td>143,000<td>13.5<td>3.4<td><strong>4x</strong></table><p>As mentioned at the start of this post, the Rust code using Rayon is about 4x faster than the Python code. This speedup would likely increase as the number of records increases. The difference can be explained by the fact that Rayon allows for easy parallelization at multiple stages of the pipeline, and that it uses work-stealing to distribute the work across multiple CPU cores, ensuring the most threads are kept utilized with minimum communication overhead.<p>Python’s <code>ProcessPoolExecutor</code> does exploit multiple cores, but not as efficiently, and each batch is processed sequentially. In addition, pure-Python objects are passed around at each stage, which adds to the overhead while not utilizing the cores to their fullest potential.<h2 id=analysis>Analysis<a aria-label="Anchor link for: analysis" class=zola-anchor href=#analysis>#</a></h2><p>It would be a shame to have done all this work without analyzing the results! Let’s quickly load the processed data into a Polars DataFrame and then calculate some statistics.<h3 id=total-articles>Total articles<a aria-label="Anchor link for: total-articles" class=zola-anchor href=#total-articles>#</a></h3><p>The results from the three CSV files can be combined into a single DataFrame in Polars. The Python code is shown below (note that the same can also be done through Polars’ Rust API).<pre class=language-py data-lang=py style=background:#2e3440;color:#d8dee9><code class=language-py data-lang=py><span style=color:#81a1c1>import </span><span>polars </span><span style=color:#81a1c1>as </span><span>pl
</span><span>
</span><span style=color:#81a1c1>def </span><span style=color:#88c0d0>get_result</span><span>() </span><span style=color:#eceff4>-> </span><span>pl</span><span style=color:#81a1c1>.</span><span>DataFrame:
</span><span>    articles1 </span><span style=color:#81a1c1>= </span><span>pl</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>read_csv</span><span>(</span><span style=color:#a3be8c>"../data/articles1_processed.csv"</span><span>)
</span><span>    articles2 </span><span style=color:#81a1c1>= </span><span>pl</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>read_csv</span><span>(</span><span style=color:#a3be8c>"../data/articles2_processed.csv"</span><span>)
</span><span>    articles3 </span><span style=color:#81a1c1>= </span><span>pl</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>read_csv</span><span>(</span><span style=color:#a3be8c>"../data/articles3_processed.csv"</span><span>)
</span><span>    </span><span style=color:#616e88># Combine the data into a single DataFrame
</span><span>    result </span><span style=color:#81a1c1>= </span><span>(
</span><span>        pl</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>concat</span><span>([articles1</span><span style=color:#eceff4>, </span><span>articles2</span><span style=color:#eceff4>, </span><span>articles3])
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>unique</span><span>(subset</span><span style=color:#81a1c1>=</span><span>[</span><span style=color:#a3be8c>"id"</span><span>])
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>sort</span><span>(</span><span style=color:#a3be8c>"id"</span><span>)
</span><span>    )
</span><span>    </span><span style=font-style:italic;color:#88c0d0>print</span><span>(</span><span style=color:#81a1c1>f</span><span style=color:#a3be8c>"Number of articles: </span><span>{result</span><span style=color:#81a1c1>.</span><span>height}</span><span style=color:#a3be8c>"</span><span>)
</span><span>    </span><span style=color:#81a1c1>return </span><span>result
</span></code></pre><p>The total number of records in the combined DataFrame after sorting and de-duplicating is shown below.<pre class=language-sh data-lang=sh style=background:#2e3440;color:#d8dee9><code class=language-sh data-lang=sh><span style=color:#88c0d0>Number</span><span> of records: 142570
</span></code></pre><h3 id=articles-per-year>Articles per year<a aria-label="Anchor link for: articles-per-year" class=zola-anchor href=#articles-per-year>#</a></h3><p>The dates exist as strings, and must first be parsed into a date format before extracting the year. Null-handling has to be performed as ~7.5k records have null dates.<pre class=language-py data-lang=py style=background:#2e3440;color:#d8dee9><code class=language-py data-lang=py><span style=color:#81a1c1>def </span><span style=color:#88c0d0>get_article_count_by_year</span><span>(df</span><span style=color:#eceff4>: </span><span>pl</span><span style=color:#81a1c1>.</span><span>DataFrame) </span><span style=color:#eceff4>-> </span><span>pl</span><span style=color:#81a1c1>.</span><span>DataFrame:
</span><span>    </span><span style=color:#616e88># Parse dates
</span><span>    result </span><span style=color:#81a1c1>= </span><span>df</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>drop_nulls</span><span>(subset</span><span style=color:#81a1c1>=</span><span style=color:#a3be8c>"date"</span><span>)</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>with_columns</span><span>(
</span><span>        pl</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>col</span><span>(</span><span style=color:#a3be8c>"date"</span><span>)</span><span style=color:#81a1c1>.</span><span>str</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>to_date</span><span>(</span><span style=color:#a3be8c>"</span><span style=color:#ebcb8b>%Y</span><span style=color:#a3be8c>-</span><span style=color:#ebcb8b>%m</span><span style=color:#a3be8c>-</span><span style=color:#ebcb8b>%d</span><span style=color:#a3be8c>"</span><span style=color:#eceff4>, </span><span>strict</span><span style=color:#81a1c1>=False</span><span>)</span><span style=color:#eceff4>,
</span><span>    )
</span><span>    </span><span style=color:#616e88># Drop nulls and extract year
</span><span>    result </span><span style=color:#81a1c1>= </span><span>(
</span><span>        result</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>filter</span><span>(pl</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>col</span><span>(</span><span style=color:#a3be8c>"date"</span><span>)</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>is_not_null</span><span>())
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>with_columns</span><span>(
</span><span>            pl</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>col</span><span>(</span><span style=color:#a3be8c>"date"</span><span>)</span><span style=color:#81a1c1>.</span><span>dt</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>year</span><span>()</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>alias</span><span>(</span><span style=color:#a3be8c>"year"</span><span>)</span><span style=color:#eceff4>,
</span><span>        )
</span><span>    )
</span><span>    </span><span style=color:#616e88># Group by year and count
</span><span>    result_by_year </span><span style=color:#81a1c1>= </span><span>(
</span><span>        result</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>group_by</span><span>(</span><span style=color:#a3be8c>"year"</span><span>)
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>len</span><span>()
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>sort</span><span>(</span><span style=color:#a3be8c>"year"</span><span style=color:#eceff4>, </span><span>descending</span><span style=color:#81a1c1>=True</span><span>)
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>head</span><span>(</span><span style=color:#b48ead>5</span><span>)
</span><span>    )
</span><span>    </span><span style=color:#81a1c1>return </span><span>result_by_year
</span></code></pre><p>As can be seen below, the most articles in the dataset were written between 2016 and 2017.<pre class=language-sh data-lang=sh style=background:#2e3440;color:#d8dee9><code class=language-sh data-lang=sh><span style=color:#88c0d0>shape:</span><span> (5, 2)
</span><span style=color:#88c0d0>┌──────┬───────┐
</span><span style=color:#88c0d0>│</span><span> year ┆ len   │
</span><span style=color:#88c0d0>│</span><span> ---  ┆ ---   │
</span><span style=color:#88c0d0>│</span><span> i32  ┆ u32   │
</span><span style=color:#88c0d0>╞══════╪═══════╡
</span><span style=color:#88c0d0>│</span><span> 2017 ┆ 48783 │
</span><span style=color:#88c0d0>│</span><span> 2016 ┆ 82148 │
</span><span style=color:#88c0d0>│</span><span> 2015 ┆ 3653  │
</span><span style=color:#88c0d0>│</span><span> 2014 ┆ 108   │
</span><span style=color:#88c0d0>│</span><span> 2013 ┆ 228   │
</span><span style=color:#88c0d0>└──────┴───────┘
</span></code></pre><h3 id=highest-mean-female-pronoun-count>Highest mean female pronoun count<a aria-label="Anchor link for: highest-mean-female-pronoun-count" class=zola-anchor href=#highest-mean-female-pronoun-count>#</a></h3><p>Counting the raw number of pronouns is not very informative, because the dataset contains an unequal distribution of articles across publications. We can thus display the <em>mean</em> value of male/female pronouns per publication to get a better sense of the dataset.<pre class=language-py data-lang=py style=background:#2e3440;color:#d8dee9><code class=language-py data-lang=py><span style=color:#81a1c1>def </span><span style=color:#88c0d0>get_pub_with_most_female_pronouns</span><span>(df</span><span style=color:#eceff4>: </span><span>pl</span><span style=color:#81a1c1>.</span><span>DataFrame) </span><span style=color:#eceff4>-> </span><span>pl</span><span style=color:#81a1c1>.</span><span>DataFrame:
</span><span>    result </span><span style=color:#81a1c1>= </span><span>(
</span><span>        df</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>group_by</span><span>(</span><span style=color:#a3be8c>"publication"</span><span>)
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>mean</span><span>()
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>select</span><span>(</span><span style=color:#a3be8c>"publication"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"num_male_pronouns"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"num_female_pronouns"</span><span>)
</span><span>        </span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>sort</span><span>(</span><span style=color:#a3be8c>"num_female_pronouns"</span><span style=color:#eceff4>, </span><span>descending</span><span style=color:#81a1c1>=True</span><span>)
</span><span>    )
</span><span>    </span><span style=color:#81a1c1>return </span><span>result</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>head</span><span>(</span><span style=color:#b48ead>5</span><span>)
</span></code></pre><p>The mean per publication is calculated and sorted in descending order by nunber of female pronouns.<pre class=language-sh data-lang=sh style=background:#2e3440;color:#d8dee9><code class=language-sh data-lang=sh><span style=color:#88c0d0>shape:</span><span> (15, 3)
</span><span style=color:#88c0d0>┌─────────────────────┬───────────────────┬─────────────────────┐
</span><span style=color:#88c0d0>│</span><span> publication         ┆ num_male_pronouns ┆ num_female_pronouns │
</span><span style=color:#88c0d0>│</span><span> ---                 ┆ ---               ┆ ---                 │
</span><span style=color:#88c0d0>│</span><span> str                 ┆ f64               ┆ f64                 │
</span><span style=color:#88c0d0>╞═════════════════════╪═══════════════════╪═════════════════════╡
</span><span style=color:#88c0d0>│</span><span> New York Times      ┆ 18.716904         ┆ 7.383955            │
</span><span style=color:#88c0d0>│</span><span> Washington Post     ┆ 15.860806         ┆ 5.739518            │
</span><span style=color:#88c0d0>│</span><span> Atlantic            ┆ 16.061847         ┆ 5.564981            │
</span><span style=color:#88c0d0>│</span><span> Guardian            ┆ 13.266214         ┆ 5.508467            │
</span><span style=color:#88c0d0>│</span><span> Buzzfeed News       ┆ 10.669551         ┆ 5.358467            │
</span><span style=color:#88c0d0>│</span><span> …                   ┆ …                 ┆ …                   │
</span><span style=color:#88c0d0>│</span><span> Fox News            ┆ 7.71107           ┆ 3.123794            │
</span><span style=color:#88c0d0>│</span><span> Breitbart           ┆ 6.774694          ┆ 2.336992            │
</span><span style=color:#88c0d0>│</span><span> Talking Points Memo ┆ 6.334676          ┆ 1.247986            │
</span><span style=color:#88c0d0>│</span><span> Business Insider    ┆ 5.295545          ┆ 1.206009            │
</span><span style=color:#88c0d0>│</span><span> Reuters             ┆ 5.809991          ┆ 1.195238            │
</span><span style=color:#88c0d0>└─────────────────────┴───────────────────┴─────────────────────┘
</span></code></pre><p>The top 5 publications with the most female pronouns are well-known news outlets like the New York Times, Washington Post, Atlantic, Guardian and Buzzfeed News. The bottom of the list contains publications like Reuters, Business Insider, Talking Points Memo, Breitbart and Fox News. Is there a trend? Possibly, or possibly not. The difference is likely due to the fact that a lot news content covers politicians, businessmen and sportspersons, who tend to be overwhelmingly male.<p>In any case, these results were easy to calculate and analyze using the methodology described above, giving an initial sense of what’s in the data.<h2 id=conclusions>Conclusions<a aria-label="Anchor link for: conclusions" class=zola-anchor href=#conclusions>#</a></h2><p>In my view as a developer, Rayon’s design offers a <strong>perfect</strong> level of abstraction for data parallelism. There’s barely any boilerplate, the Rust implementation is multiple times faster than Python and has around 10% fewer lines of code, while also being more readable and expressive. Although Rust was expected to be faster than Python all along, it normally has a reputation for being more complex and verbose than Python. When parallelism is involved, however, the opposite is true, thanks to Rayon.<p>The parallelization approaches in Python and Rust could not be more different. Python’s <code>ProcessPoolExecutor</code> requires the user to specify the maximum number of CPU worker processes to use, batch the data and handle errors. In Rust, Rayon provides parallel iterators and work-stealing to efficiently distribute the work across multiple threads. Because of Rayon’s design, the most CPU cores (and associated threads) are kept active at all times without any user input, meaning that the developer can focus on the program’s logic and let the library handle the parallelization.<p>This post showed a relatively simple use case in which we do not need to mutate shared state across threads, but Rayon is capable of far more complex parallelization logic. It’s highly recommended to read the Rayon <a rel="nofollow noreferrer" href=https://github.com/rayon-rs/rayon/blob/master/FAQ.md>FAQ</a> page to learn more about how it works under the hood and try it out for more advanced use cases.<p>While this post clearly separated Python and Rust into distinct workflows, it’s worth noting that Rust can be used to write performance-critical extensions that can be exposed to Python via PyO3, and that Rayon can be used to power such extensions. This is a topic for a future blog post, so stay tuned! Till then, have fun coding in Rust! 🚀<h2 id=code>Code<a aria-label="Anchor link for: code" class=zola-anchor href=#code>#</a></h2><p>The code for the Python and Rust implementations is available <a rel="nofollow noreferrer" href=https://github.com/thedataquarry/rustinpieces/tree/main/src/parallelism>here</a>. It’s part of a larger project called <a rel="nofollow noreferrer" href=https://github.com/thedataquarry/rustinpieces>Rust in Pieces</a>, in which I’m collaborating with <a rel="nofollow noreferrer" href=https://github.com/sanders41>Paul Sanders</a> to compare Python and Rust for data processing tasks. If you found this post interesting, consider giving the GitHub repo a star ⭐️ and follow along!<hr><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>Rayon started off as a hobby project by Niko Matsakis, though it has since grown into a widely used crate in the Rust ecosystem. See the talk <em><a href="https://www.youtube.com/watch?v=gof_OEv71Aw" rel="nofollow noreferrer">Rayon: Data Parallelism for fun and profit</a></em> for a great introduction.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p><a rel="nofollow noreferrer" href=http://supertech.csail.mit.edu/papers/steal.pdf>Scheduling Multithreaded Computations by Work Stealing</a>, by Blumofe and Leiserson</div></article><div class=giscus></div><script async crossorigin data-category=General data-category-id=DIC_kwDOKyWhTs4CbUSt data-emit-metadata=0 data-input-position=bottom data-lang=en data-loading=lazy data-mapping=pathname data-reactions-enabled=1 data-repo=thedataquarry/thedataquarry.github.io data-repo-id=R_kgDOKyWhTg data-strict=0 data-theme=preferred_color_scheme src=https://giscus.app/client.js></script></div><footer><div class=copyright><p>© 2024 Prashanth Rao</div><div class=credits>Powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div></footer></main></div><script src=/js/lightense.min.js></script><script src=/js/main.js></script>